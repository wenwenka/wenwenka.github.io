<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CsApp —— Malloc Lab | 温温卡的blog</title><meta name="author" content="wenwenka,wu290063155@gmail.com"><meta name="copyright" content="wenwenka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="准备工作相关的作业是在 CMU 的官网上： Lab Assignments 在Malloc Lab一栏中，我们可以查看相关文件，例如：  Readme 文档 Writeup PDF 说明材料 作业原件)  作业区域本实验的作业部分均集中在mm.c文件中，这里内部包含了我们需要完成的多个核心方法。 测试程序：通过mdriver.c，我们可以对代码进行性能检测，可以通过 make 命令来生成相关的代码">
<meta property="og:type" content="article">
<meta property="og:title" content="CsApp —— Malloc Lab">
<meta property="og:url" content="http://example.com/2023/05/13/CsApp-%E2%80%94%E2%80%94-mallocLab/index.html">
<meta property="og:site_name" content="温温卡的blog">
<meta property="og:description" content="准备工作相关的作业是在 CMU 的官网上： Lab Assignments 在Malloc Lab一栏中，我们可以查看相关文件，例如：  Readme 文档 Writeup PDF 说明材料 作业原件)  作业区域本实验的作业部分均集中在mm.c文件中，这里内部包含了我们需要完成的多个核心方法。 测试程序：通过mdriver.c，我们可以对代码进行性能检测，可以通过 make 命令来生成相关的代码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/05/13/CsApp-%E2%80%94%E2%80%94-mallocLab/cover.jpg">
<meta property="article:published_time" content="2023-05-13T10:36:00.000Z">
<meta property="article:modified_time" content="2023-05-13T10:42:13.585Z">
<meta property="article:author" content="wenwenka">
<meta property="article:tag" content="CsApp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/05/13/CsApp-%E2%80%94%E2%80%94-mallocLab/cover.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/05/13/CsApp-%E2%80%94%E2%80%94-mallocLab/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CsApp —— Malloc Lab',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-13 18:42:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2023/05/13/CsApp-%E2%80%94%E2%80%94-mallocLab/cover.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">温温卡的blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CsApp —— Malloc Lab</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-13T10:36:00.000Z" title="发表于 2023-05-13 18:36:00">2023-05-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-13T10:42:13.585Z" title="更新于 2023-05-13 18:42:13">2023-05-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CsApp —— Malloc Lab"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>相关的作业是在 CMU 的官网上：</p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/labs.html">Lab Assignments</a></p>
<p>在Malloc Lab一栏中，我们可以查看相关文件，例如：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/README-malloclab">Readme</a> 文档</li>
<li><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/malloclab.pdf">Writeup</a> PDF 说明材料</li>
<li><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/malloclab.pdf">作业原件)</a></li>
</ul>
<h2 id="作业区域"><a href="#作业区域" class="headerlink" title="作业区域"></a>作业区域</h2><p>本实验的作业部分均集中在mm.c文件中，这里内部包含了我们需要完成的多个核心方法。</p>
<h2 id="测试程序："><a href="#测试程序：" class="headerlink" title="测试程序："></a>测试程序：</h2><p>通过mdriver.c，我们可以对代码进行性能检测，可以通过 <code>make</code> 命令来生成相关的代码。</p>
<blockquote>
<p>在编译过程中，如果遇到 <code>/usr/include/gnu/stubs.h:7:11: fatal error: gnu/stubs-32.h: No such file or directory</code> 相关的问题，应该是 32 位兼容的问题… 目测前往 <code>Makefile</code> 中，将编译选项中的 <code>-m32</code> 修改为 <code>-m64</code> 即可，接下来执行 <code>make clean; make</code> 即可。</p>
</blockquote>
<p>由于实验所用机器是64位的，因此需要在编译的时候进行调整。</p>
<p>由于实验没有直接提供trace文件，因此直接使用了网上的trace。</p>
<p><a target="_blank" rel="noopener" href="https://blog.rayzhang.top/2022/05/25/csapp-malloclab/traces.zip">trace文件</a></p>
<p><code>mdriver.c</code>的使用参数如下：</p>
<ul>
<li><code>-t &lt;tracedir&gt;</code>：通过此参数，我们将指定 <code>trace</code> 文件所在的目录，而非使用默认的文件夹，默认的目录被定义在了 <code>config.h</code> 中，我们看到有：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TRACEDIR <span class="string">&quot;/afs/cs/project/ics2/im/labs/malloclab/traces/&quot;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>显然要么改 <code>config.h</code> 内部的配置，要么运行的时候自己定义路径… 我们又不是 CMU 的学生，这些 <code>trace</code> 文件我们也没有…</li>
<li>  <code>-f &lt;tracefile&gt;</code>：或者我们干脆直接指定某一个 <code>trace</code> 文件，而非 <code>config.h</code> 中的记录的默认文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_TRACEFILES \  </span></span><br><span class="line">  <span class="string">&quot;amptjp-bal.rep&quot;</span>,\  </span><br><span class="line">  <span class="string">&quot;cccp-bal.rep&quot;</span>,\  </span><br><span class="line">  <span class="string">&quot;cp-decl-bal.rep&quot;</span>,\  </span><br><span class="line">  <span class="string">&quot;expr-bal.rep&quot;</span>,\  </span><br><span class="line">  <span class="string">&quot;coalescing-bal.rep&quot;</span>,\  </span><br><span class="line">  <span class="string">&quot;random-bal.rep&quot;</span>,\  </span><br><span class="line">  <span class="string">&quot;random2-bal.rep&quot;</span>,\  </span><br><span class="line">  <span class="string">&quot;binary-bal.rep&quot;</span>,\  </span><br><span class="line">  <span class="string">&quot;binary2-bal.rep&quot;</span>,\  </span><br><span class="line">  <span class="string">&quot;realloc-bal.rep&quot;</span>,\  </span><br><span class="line">  <span class="string">&quot;realloc2-bal.rep&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>-h</code>：打印命令行参数使用帮助</li>
<li><code>-l</code>：同时测试我们的 <code>mm_malloc</code> 和 <code>libc</code> 标准库中的对应函数，并进行比较</li>
<li><code>-v</code>：在一个紧凑的表格中打印出每个跟踪文件的性能表现</li>
<li>  <code>-V</code>：更多的中间过程输出，在处理每个跟踪文件时打印额外的诊断信息。在调试过程中很有用，我们可以通过打印的信息确定是哪个跟踪文件导致你的 <code>malloc</code> 失败</li>
</ul>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h2 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h2><h3 id="主体函数"><a href="#主体函数" class="headerlink" title="主体函数"></a>主体函数</h3><p>我们需要实现的主体函数有如下四个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span>;  </span><br><span class="line"><span class="type">void</span>* <span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span>;  </span><br><span class="line"><span class="type">void</span>* <span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在<code>mm.c</code>文件中，已经预先提供了一个最简单的<code>malloc</code>方法，在PDF中，作者推荐我们去尝试不同的动态内存分配可能。以上四个函数的要求如下：</p>
<ul>
<li><p><code>mm_init</code>：在调用 <code>mm_malloc</code>，<code>mm_realloc</code> 或 <code>mm_free</code> 之前，调用 <code>mm_init</code> 进行初始化，正确返回 <code>0</code>，有问题则返回 <code>-1</code></p>
</li>
<li><ul>
<li>  <code>mm_malloc</code>：在堆区域分配至少 <code>size</code> 大小的空间，返回的指针应该是 <code>8</code> 字节对齐的。同时确保分配的内存空间不会与其他已分配的内存块重叠</li>
</ul>
</li>
<li><p>  <code>mm_free</code>：释放 <code>ptr</code> 所指向的内存块。</p>
</li>
<li><p><code>mm_realloc</code>：返回指向一个大小至少为 <code>size</code> 的区域指针，满足以下条件：</p>
<ul>
<li>如果 <code>ptr</code> 为 <code>NULL</code>，则调用相当于 <code>mm_malloc(size)</code></li>
<li>如果 <code>size</code> 大小为 <code>0</code>，则调用相当于 <code>mm_free(ptr)</code></li>
<li>  如果 <code>ptr</code> 不为 <code>NULL</code>，且 <code>ptr</code> 为之前某次调用 <code>mm_malloc</code> 或者 <code>mm_realloc</code> 返回的指针。本次调用将改变 <code>ptr</code> 指向的内存块的大小，将其变为 <code>size</code> 个字节，并返回新内存块的地址。</li>
</ul>
</li>
</ul>
<blockquote>
<p>P. S. 注意到新内存块的地址可以和旧内存块的地址一致，也可以不同，取决于你的实现、旧内存块内部碎片大小和本次 <code>realloc</code> 请求的 <code>size</code> 大小。</p>
<p>新内存块内部存储的内容应当和旧内存块一致，取决于新旧大小的最小值。</p>
<p>例如，原来有一个 <code>8</code> 字节的旧内存块，现在我们将其变为 <code>12</code> 字节，则有前 <code>8</code> 字节保持不变而后 <code>4</code> 字节未初始化。</p>
<p>或者，原来有一个 <code>8</code> 字节的旧内存块，现在将其大小变为 <code>4</code> 字节，则新内存块中的头部 <code>4</code> 字节应当和旧内存块一致。</p>
</blockquote>
<h3 id="内存检查器"><a href="#内存检查器" class="headerlink" title="内存检查器"></a>内存检查器</h3><p>除了要实现以上分配内存的函数外，还需要实现内存一致性的检查器。在运行时，该检查器将对整个堆的内存空间进行扫描，例如需要检查的问题包括但不限于：</p>
<ul>
<li>  是否在空闲列表中的每一个内存块均被标记为空闲状态？</li>
<li>  是否存在连续的空闲内存块忘记被合并了？</li>
<li>  空闲列表在每次操作后是否包含了所有的空闲内存块？</li>
<li>  空闲列表中的指针是否指向了有效的空闲内存块？</li>
<li>  已分配的内存块之间有没有出现重叠的异常状况？</li>
<li>  在堆内存块中的指针是否指向了有效的对内存地址？</li>
</ul>
<p>PDF 中希望我们将内存检查器写作 <code>int mm_check(void)</code>，一并写在 <code>mm.c</code> 文件中，并希望当内存通过检查时，该方法返回一个非 <code>0</code> 值。当内存检查未通过时，也可打印对应的错误信息方便排查。</p>
<blockquote>
<p>P. S. 最终对 <code>mm.c</code> 进行性能测试时，务必将 <code>mm_check</code> 内存检查器的相关调用加上注释，以避免不必要的性能损失。</p>
</blockquote>
<h3 id="示例理解"><a href="#示例理解" class="headerlink" title="示例理解"></a>示例理解</h3><p>在初始的<code>mm.c</code>程序中，<code>mm_malloc</code>和<code>mm_realloc</code>已经被给出，并且定义了几个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT 8  </span></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br></pre></td></tr></table></figure>

<p>其中，ALIGN(size) 的目的是将size进行双字对齐操作，而SIZE_T_SIZE进一步使用了该操作，应该是用来表示内存块的头部大小的。</p>
<p>因此在我们正式计算一个内存块的大小时，应当是头部大小对齐后的值加上有效载荷的大小后再进行对齐的值。隐式的空闲链表分配如下所示：<br><img src="20230507200317.png"></p>
<p><img src="20230507200324.png"></p>
<p>初始设置的<code>mm_malloc</code>函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.  </span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> newsize = ALIGN(size + SIZE_T_SIZE); <span class="comment">//需要申请的空间大小  </span></span><br><span class="line">    <span class="type">void</span> *p = mem_sbrk(newsize); <span class="comment">//传给mem_sbrk的incr参数，申请扩大堆空间  </span></span><br><span class="line">    <span class="keyword">if</span> (p == (<span class="type">void</span> *)<span class="number">-1</span>) <span class="comment">//申请失败，返回NULL  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//申请成功  </span></span><br><span class="line">        *(<span class="type">size_t</span> *)p = size;  <span class="comment">//在内存块头部中写入大小信息  </span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)((<span class="type">char</span> *)p + SIZE_T_SIZE); <span class="comment">//加上头部大小偏移量，返回指向有效载荷的指针  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>P. S. 可以看到这里面申请的 <code>size</code> 看起来应该就是有效载荷的大小，并不计入头部块大小等内容，和上文中给出的图还是有一点小出入的，需要注意一下。</p>
<p>由于使用了 <code>size_t</code> 作为头部块大小的描述方式，在 <code>32</code> 位系统下为 <code>4</code> 字节，在 <code>64</code> 位下应当为 <code>8</code> 字节，再加上头部和有效载荷均应该是 <code>8</code> 字节对齐的（第一个内存块的头部是落在堆内存空间的头部，而堆内存空间是通过 <code>malloc</code> 分配的，自然也应当是 <code>8</code> 字节对齐的，详情见下文）</p>
<p>也许应该画成下面这个样子比较合适？<br><img src="20230507201313.png"></p>
</blockquote>
<center>64 位系统下</center>

<p><img src="20230507201424.png"></p>
<center>32 位系统下</center>

<p>有兴趣的话还可以去 <code>memlib.c</code> 中了解一下 <code>mem_sbrk</code> 是如何实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_start_brk; <span class="comment">/* points to first byte of heap */</span>  </span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_brk;       <span class="comment">/* points to last byte of heap */</span>  </span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_max_addr;  <span class="comment">/* largest legal heap address */</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * mem_init - initialize the memory system model  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="type">void</span> <span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span> &#123;  </span><br><span class="line">    <span class="comment">/* allocate the storage we will use to model the available VM */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((mem_start_brk = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MAX_HEAP)) == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;mem_init_vm: malloc error\n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    mem_max_addr = mem_start_brk + MAX_HEAP; <span class="comment">/* max legal heap address */</span>  </span><br><span class="line">    mem_brk = mem_start_brk;                 <span class="comment">/* heap is empty initially */</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * mem_sbrk - simple model of the sbrk function. Extends the heap  </span></span><br><span class="line"><span class="comment"> *    by incr bytes and returns the start address of the new area. In  </span></span><br><span class="line"><span class="comment"> *    this model, the heap cannot be shrunk.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">mem_sbrk</span><span class="params">(<span class="type">int</span> incr)</span> &#123;  </span><br><span class="line">    <span class="type">char</span> *old_brk = mem_brk;</span><br><span class="line">    <span class="keyword">if</span> ((incr &amp;lt; <span class="number">0</span>) || ((mem_brk + incr) &amp;gt; mem_max_addr)) &#123;   </span><br><span class="line">      <span class="comment">//如果预计修改后的堆内存超过上限或者想要收缩堆大小，则报错  </span></span><br><span class="line">        errno = ENOMEM;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ERROR: mem_sbrk failed. Ran out of memory...\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mem_brk += incr;  </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)old_brk; <span class="comment">//否则返回原堆内存上界指针  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 <code>mem_brk</code> 是已经使用的堆内存的上限指针，而非堆内存的最大地址。模型如下所示，注意指针指向的位置：</p>
<p><img src="heap.jpg"></p>
<p>简单的说，该函数根据传入的 <code>incr</code> 大小，修改堆已使用内存的大小（堆内存本身的大小被固定为 <code>MAX_HEAP</code>，查询 <code>config.h</code> 可知默认为 <code>20MB</code>），将堆已使用内存的上限指针移动，如果成功则返回修改前的堆上限位置的指针，否则返回 <code>-1</code>。</p>
<p>在上面 <code>mm_malloc</code> 的例子中，完成扩容后，我们修改的位置指向了刚申请的新内存空间，在刚申请的内存空间中进行处理没有数据污染的风险。</p>
<p>接下来，我们看 <code>mm_realloc</code> 函数，其功能为修改指向的内存块的大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span> &#123;  </span><br><span class="line">    <span class="type">void</span> *oldptr = ptr;  </span><br><span class="line">    <span class="type">void</span> *newptr;  </span><br><span class="line">    <span class="type">size_t</span> copySize;  </span><br><span class="line">  </span><br><span class="line">    newptr = mm_malloc(size); <span class="comment">//先开辟相应的空间  </span></span><br><span class="line">    <span class="keyword">if</span> (newptr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//如果申请内存失败，直接返回NULL  </span></span><br><span class="line">    copySize = *(<span class="type">size_t</span> *)((<span class="type">char</span> *)oldptr - SIZE_T_SIZE); <span class="comment">//确定原内存块的大小（通过读取其头部块实现）  </span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; copySize) copySize = size; <span class="comment">//如果修改后内存还不如当前块内存大，将复制的数据量控制为size  </span></span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, oldptr, copySize); <span class="comment">//使用memcpy将原内存块中的东西拷贝到现内存块地址下  </span></span><br><span class="line">    mm_free(oldptr); <span class="comment">//释放原内存块空间  </span></span><br><span class="line">    <span class="keyword">return</span> newptr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他甚至只在头部嵌进去了块大小，也没见加入已分配的标记位… 也不知道这么搞怎么区分空闲块和已分配块…</p>
<h2 id="策略与代码"><a href="#策略与代码" class="headerlink" title="策略与代码"></a>策略与代码</h2><h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>在书中已经有了一个隐式空闲链表的实现示例（p897），只是没有mm_realloc find_fit place 这些功能。</p>
<h4 id="空闲块的组织"><a href="#空闲块的组织" class="headerlink" title="空闲块的组织"></a>空闲块的组织</h4><p>每个空闲块的结构如下：</p>
<p><img src="20230511144328.png"></p>
<ul>
<li>脚部与头部是相同的，均为-   4 个字节，用来存储块的大小，以及表明这个块是已分配还是空闲块</li>
<li>  由于要求块双字对齐，所以块大小就总是 8 的倍数，低 3 位总是为 0，因而，我们只需要利用头部和脚部的高 29 位存储块的大小，剩下 3 位的最低位来指明这个块是否空闲，000 为空闲，001 为已分配</li>
</ul>
<p><img src="20230511144155.png"></p>
<p>堆有两个特殊的标记：</p>
<ul>
<li>序言块（Prologue Block）: 大小为8个字节，由一个头部和一个脚部组成</li>
<li>结尾块（Epilogure Block）：大小为0的头部</li>
</ul>
<p>为了消除合并空闲块时边界的考虑，将序言块和结尾块的分配位均设置为已分配。为了保证双字对齐，在序言块的前面还设置了 4 个字节作为填充。分配器使用一个单独的私有全局变量 <code>heap_listp</code>，他总是指向序言块。</p>
<p>根据上述结构，可以定义一些方便操作的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头部/脚部的大小 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4</span></span><br><span class="line"><span class="comment">/* 双字 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 扩展堆时的默认大小 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="comment">/* 设置头部和脚部的值, 块大小+分配位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读写指针p的位置 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) ((*(unsigned int *)(p)) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从头部或脚部获取大小或分配位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定有效载荷指针, 找到头部和脚部 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char*)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char*)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定有效载荷指针, 找到前一块或下一块 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char*)(bp) + GET_SIZE(((char*)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char*)(bp) - GET_SIZE(((char*)(bp) - DSIZE)))</span></span><br></pre></td></tr></table></figure>

<p>以及一些变量的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span>* heap_list;</span><br></pre></td></tr></table></figure>

<p><code>WSIZE</code> 代表了一个字的大小即 <code>4</code> 字节，<code>DSIZE</code> 代表了一个双字的大小即 <code>8</code> 字节。初始空闲块的大小和扩展堆时的默认大小为 <code>CHUKSIZE</code>。</p>
<p><code>PACK</code> 通过位运算，将块大小和分配标识符结合，生成一个字，可以将其存储在头部和脚部中。</p>
<p><code>GET</code> 用于读取参数 <code>p</code> 引用的字，<code>PUT</code> 用于存放在参数 <code>p</code> 指向的字。更进一步的，通过适当的位运算，使用 <code>GET_SIZE</code>，可以将 <code>p</code> 引用的字中的块内存大小信息提取出来，使用 <code>GET_ALLOC</code> 可以将分配标识提取出来。</p>
<p>假设 <code>bp</code> 指向的是有效载荷首地址，则我们通过对应的偏移量，使用 <code>HDRP</code> 可以确定头部指针，使用 <code>FTRP</code> 可以确定脚步指针。</p>
<p>相似的，我们通过偏移量（这也就是隐式空闲链表的精髓，并没有指针链接各个节点，一切都是通过偏移量实现的）可以确定后面的块和前面的块的指针，通过 <code>NEXT_BLKP</code> 和 <code>PREV_BLKP</code> 来实现，<code>(char *)(bp) - WSIZE</code> 指向的是当前块内存的头部，而 <code>(char *)(bp) - DSIZE</code> 指向的是前一块内存块的脚部。</p>
<h4 id="合并与分割"><a href="#合并与分割" class="headerlink" title="合并与分割"></a>合并与分割</h4><h5 id="初始化堆"><a href="#初始化堆" class="headerlink" title="初始化堆"></a>初始化堆</h5><p>在初始化堆时，按照书中所给的模型，我们首先应当划分出序言块、结尾块以及初始位置的空间（如之前空闲链表的蓝色位置所示），这部分的内存需要调用mem_sbrk进行申请。</p>
<p>接下来，我们再将对应内容填入即可，正如上图中所示的，第一个字是一个双字边界对齐的不使用的填充字，用 <code>0</code> 填充即可，序言块中头部尾部分别是 <code>8/1</code> 和 <code>8/1</code>，结尾块为 <code>0/1</code> 的头部。</p>
<p>最后我们还将调用 <code>extend_heap</code>，将堆扩展 <code>CHUNKSIZE</code> 字节，并创建初始的空闲块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 申请四个字节空间 */</span></span><br><span class="line">    <span class="keyword">if</span> ((heap_list = mem_sbrk(<span class="number">4</span>*WSIZE)) == (<span class="type">void</span> *) - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_list, <span class="number">0</span>);                                   <span class="comment">/* 对齐 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 序言块和结尾块均设置为已分配，方便考虑边界情况</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PUT(heap_list + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));        <span class="comment">/* 填充序言块头部 */</span></span><br><span class="line">    PUT(heap_list + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));        <span class="comment">/* 填充序言块尾部 */</span></span><br><span class="line">    PUT(heap_list + (<span class="number">3</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));        <span class="comment">/* 结尾块 */</span></span><br><span class="line">  </span><br><span class="line">    heap_list += (<span class="number">2</span> * WSIZE);                            <span class="comment">/* 将heap_list置于正确位置 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩展空闲空间 */</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展堆的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   扩展heap，传入的是字节数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span>&#123;</span><br><span class="line">    <span class="comment">/* bp总是指向有效载荷 */</span></span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="comment">/* 根据传入字节数的奇偶性，考虑对齐 */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配 */</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置头部和尾部 */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));            <span class="comment">/* 空闲块头 */</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));            <span class="comment">/* 空闲块脚 */</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));    <span class="comment">/* 新结尾块设置*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断相邻块是否是空闲块，进行合并 */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数应该是每次空闲空间不足时，向堆内存申请更多内存用的。每次申请偶数个字的内存空间，以确保内存是对齐的，随后我们将新分配的内存按照空闲块的标准进行头部和脚部的标记。</p>
<p>值得注意的是，扩展堆每次在原始堆的尾部申请空间，<code>mem_sbrk</code>函数返回指向旧堆尾部的指针，因此，可以直接将原始堆的尾部位置设置新空闲块的头部。我们直接将 <code>bp</code> 定为新申请空闲内存的有效载荷，因此写其头部的时候会直接覆盖刚才的结尾块，妙啊～以后循环往复，我们创建新的空闲块，抹掉上次的结尾块改成头部，自己再最后加一块结尾块上去…</p>
<p>当然新申请的空闲内存块可能和前面的空闲块有需要合并的情形，有可能前一个堆以一个空闲块结束，因此我们需要调用 <code>coalesce</code> 函数合并两个空闲块，并最终返回合并后的块的指针。关于合并的具体细节，留到下一部分再聊…</p>
<p>接下来考虑一下free的实现，设置一下头部和尾部即可，free完后要注意合并空闲块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于合并的逻辑较复杂，因此先让我们考虑分割的实现，即place的实现。<br><code>place</code>要求我们将某个空闲内存块截断，前段设置为分配块，后半段设置为空闲块。</p>
<p>我们的基本原则是，如果空闲块的大小和需要分配的空间大小之差超过了一个空闲块的最低需求大小（也就是 <code>16</code> 字节，<code>8</code> 字节留给头部和脚部，另外 <code>8</code> 字节作为满足对齐的最低要求），那么就是有必要做截断的，否则直接将整块记为已分配即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> asize)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> block_size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">if</span> ((block_size - asize) &gt;= (<span class="number">2</span> * DSIZE)) &#123; <span class="comment">// 需要截断</span></span><br><span class="line">        PUT(HDRP(ptr), PACK(asize, <span class="number">1</span>));        <span class="comment">// 修改头部</span></span><br><span class="line">        PUT(FTRP(ptr), PACK(asize, <span class="number">1</span>));        <span class="comment">// 沿着刚修改的头部，找到重新定位后的尾部</span></span><br><span class="line">        ptr = NEXT_BLKP(ptr);                  <span class="comment">// 沿着刚修改的头部，找到未分配块的有效载荷</span></span><br><span class="line">        PUT(HDRP(ptr), PACK(block_size - asize, <span class="number">0</span>));   <span class="comment">// 修改空闲块头部的分配大小</span></span><br><span class="line">        PUT(FTRP(ptr), PACK(block_size - asize, <span class="number">0</span>));   <span class="comment">// 修改空闲块尾部的分配大小</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不需要截断，修改头部尾部即可</span></span><br><span class="line">        PUT(HDRP(ptr), PACK(block_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(ptr), PACK(block_size, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是合并逻辑的处理：<br>合并需要考虑四种情况：</p>
<ul>
<li>  前面的块和后面的块都是已分配的</li>
<li>  前面的块是已分配的，后面的块是空闲的</li>
<li>  前面的块是空闲的，后面的块是已分配的</li>
<li>  前面的块和后面的块都是空闲的</li>
</ul>
<p><img src="20230511154847.png"></p>
<p>而合并的操作，我们将通过<code>coalesce</code>操作实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   合并空闲块</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> * bp)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));        <span class="comment">/* 前一块是否分配 */</span></span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));        <span class="comment">/* 后一块是否分配 */</span></span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));                          <span class="comment">/* 当前块大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">// Case 1</span></span><br><span class="line">        <span class="keyword">return</span> bp;                                            <span class="comment">/*前后都已分配，什么都不做*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123; <span class="comment">// Case 2</span></span><br><span class="line">        <span class="comment">// 后一块空闲，前一块不空闲</span></span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));               <span class="comment">/* 更新新的空闲块大小 */</span></span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));                        <span class="comment">/* 修改空闲块头部 */</span></span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));                        <span class="comment">/* 修改空闲块尾部 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">// Case 3</span></span><br><span class="line">        <span class="comment">// 前一块空闲，后一块不空闲</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));               <span class="comment">/* 更新新的空闲块大小 */</span></span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));                        <span class="comment">/* 修改空闲块尾部 */</span></span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));             <span class="comment">/* 找到前块空闲块的头部进行修改 */</span></span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// Case 4</span></span><br><span class="line">        <span class="comment">// 前后块均空闲</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(HDRP(NEXT_BLKP(bp)));  <span class="comment">/* 更新新的空闲块大小 */</span></span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));             <span class="comment">/* 找到前块空闲块的头部进行修改 */</span></span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));             <span class="comment">/* 找到后块空闲块的尾部进行修改 */</span></span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h4><p>我们需要通过<code>find_fit</code>方法来实现对空闲链表的搜索，根据请求的内存块大小asize取出足够大的空闲列表。</p>
<p>众所周知，匹配的时候有三种不同的方法，分别是：</p>
<ul>
<li>  从头遍历，寻找第一个满足大小要求的块（First fit）</li>
<li>  从上次搜索结束的位置开始搜索（Next fit）</li>
<li>  完整遍历空闲链表，寻找<strong>最适合</strong>的空闲内存块，即最少字节剩余的（可以认为是寻找大小大于等于 <code>asize</code> 的最小块）（Best fit）</li>
</ul>
<p><img src="20230511161126.png"></p>
<p>这里参考网上博主的答案，放一下首次适配和最佳适配的方法：</p>
<p>首次适配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">first_fit</span><span class="params">(<span class="type">size_t</span> asize)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *bp;</span><br><span class="line">    <span class="keyword">for</span> (bp = heap_list; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span> ; bp = NEXT_BLKP(bp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((GET_SIZE(HDRP(bp))) &gt;= asize &amp;&amp; (!GET_ALLOC(HDRP(bp)))) <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最佳适配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">best_fit</span><span class="params">(<span class="type">size_t</span> asize)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *bp;</span><br><span class="line">	<span class="type">void</span> *best_bp;</span><br><span class="line">	<span class="type">size_t</span> min_size = <span class="number">0xffffffff</span>;;</span><br><span class="line">	<span class="keyword">for</span> (bp = heap_list; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span> ; bp = NEXT_BLKP(bp)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (GET_ALLOC(HDRP(bp))) <span class="keyword">continue</span>;  <span class="comment">//跳过已分配块</span></span><br><span class="line">		<span class="type">size_t</span> block_size = GET_SIZE(HDRP(bp));</span><br><span class="line">		<span class="keyword">if</span> (block_size &gt;= asize &amp;&amp; block_size &lt; min_size) &#123;</span><br><span class="line">			min_size = block_size;</span><br><span class="line">			best_bp = bp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> best_bp;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="分配块"><a href="#分配块" class="headerlink" title="分配块"></a>分配块</h4><p>分配块将由<code>mm_malloc</code>函数实现，对申请的空间大小按 8 对齐进行舍入，然后根据放置策略查找有无合适的空闲块，如果没有则申请扩展堆</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> asize;</span><br><span class="line">    <span class="type">size_t</span> extend_size;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE) asize = <span class="number">2</span> * DSIZE; <span class="comment">// 至少16字节</span></span><br><span class="line">    <span class="keyword">else</span> asize = DSIZE * ((size + (DSIZE) + (DSIZE - <span class="number">1</span>)) / DSIZE); <span class="comment">// 向上与8字节对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找合适的空闲块</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = best_fit(asize)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找不到则扩展堆</span></span><br><span class="line">    extend_size = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extend_size / WSIZE)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重分配块的实现"><a href="#重分配块的实现" class="headerlink" title="重分配块的实现"></a>重分配块的实现</h4><p>我们直接参考要求标准，分情况讨论即可。</p>
<ul>
<li>  如果 <code>size</code> 为 <code>0</code>，等同于 <code>mm_free</code>；</li>
<li>  如果 <code>ptr</code> 为 <code>NULL</code>，等同于 <code>mm_malloc</code>；</li>
<li>  否则，分配新内存空间，将本内存块中的内容转移过去之后，再将本块销毁；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span> &#123;  </span><br><span class="line">    <span class="type">size_t</span> oldsize;  </span><br><span class="line">    <span class="type">void</span> *newptr;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* If size == 0 then this is just free, and we return NULL. */</span>  </span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;  </span><br><span class="line">        mm_free(ptr);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* If oldptr is NULL, then this is just malloc. */</span>  </span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> mm_malloc(size);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    newptr = mm_malloc(size);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* If realloc() fails the original block is left untouched  */</span>  </span><br><span class="line">    <span class="keyword">if</span> (!newptr) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Copy the old data. */</span>  </span><br><span class="line">    oldsize = GET_SIZE(HDRP(ptr)) - DSIZE;  </span><br><span class="line">    <span class="keyword">if</span> (size &lt; oldsize) oldsize = size;  </span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, ptr, oldsize);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Free the old block. */</span>  </span><br><span class="line">    mm_free(ptr);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> newptr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>最后，使用以下命令进行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make </span><br><span class="line">./mdriver -V -t ./traces</span><br></pre></td></tr></table></figure>

<p>可得到以下结果：<br><img src="20230511165841.png"></p>
<h3 id="Segregated-Free-Lists-实现"><a href="#Segregated-Free-Lists-实现" class="headerlink" title="Segregated Free Lists 实现"></a>Segregated Free Lists 实现</h3><p>分离适配（Segregated fit），其实是在显式链表的基础上实现的，我们先来看一下显式链表的结构：</p>
<p><img src="20230512145321.png"></p>
<p>可以看到空闲块的每一个块都有一个头部和尾部，在有效载荷中又分别存放着指向前一个块和后一个块的指针。每个空闲块最小为16个字节。</p>
<p>而分离适配，则是在以上基础上，将链表分配成多个组合，将尺寸相近的链表放在一起存储：</p>
<p><img src="20230512145447.png"></p>
<p>如果将上述结构放进堆里，可以如下所示：</p>
<p><img src="20230512145630.png"></p>
<p>相当于在原来的堆结构（隐式链表）中增加了两点：</p>
<ul>
<li>  堆结构的前面放置不同等价类空闲块的头指针</li>
<li>  每个空闲块的有效载荷分出一部分作为前驱和后继指针</li>
</ul>
<p>也就是说，我们的这个做法与 Implicit Free List 非常相似，只不过多维护了 n 个链表</p>
<h4 id="定义宏"><a href="#定义宏" class="headerlink" title="定义宏"></a>定义宏</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 读写指针p的位置 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="comment">/* 给定序号，找到链表头节点位置 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_HEAD(num) ((unsigned int *)(long)(GET(heap_list + WSIZE * num)))</span></span><br><span class="line"><span class="comment">/* 给定bp,找到前驱和后继 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_PRE(bp) ((unsigned int *)(long)(GET(bp)))  <span class="comment">//由于bp指向的是空闲块的前驱指针位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SUC(bp) ((unsigned int *)(long)(GET((unsigned int *)bp + 1)))</span></span><br></pre></td></tr></table></figure>

<p>这里指针转换很繁杂，操作完后，一定要将其强制转换为<code>unsigned int *</code>，这样，返回的指针加 1 相当于加 32 个字节，便于定位块中其他部位。</p>
<h4 id="大小类设置"><a href="#大小类设置" class="headerlink" title="大小类设置"></a>大小类设置</h4><p>由上述结构，每个空闲块最小也要 16 个字节，理论上来说，设置的大小类越多，时间性能要越好，因而设置 20 个大小类： </p>
<p>$${16},{17∼32},{33∼64},⋯,{2049∼4096},{4097∼9194},⋯,{2^{22}+1∼∞}$$</p>
<h4 id="结构建立"><a href="#结构建立" class="headerlink" title="结构建立"></a>结构建立</h4><p>初始化函数构建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 申请空间 */</span></span><br><span class="line">    <span class="keyword">if</span> ((heap_list = mem_sbrk((<span class="number">4</span> + CLASS_SIZE)*WSIZE)) == (<span class="type">void</span> *) - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* 初始化20个大小的类头指针 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CLASS_SIZE; i++) &#123;</span><br><span class="line">        PUT(heap_list + i * WSIZE, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PUT(heap_list + CLASS_SIZE * WSIZE, <span class="number">0</span>);                             <span class="comment">/* 对齐 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 序言块和结尾块均设置为已分配，方便考虑边界情况</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PUT(heap_list + ((<span class="number">1</span> + CLASS_SIZE) * WSIZE), PACK(DSIZE, <span class="number">1</span>));        <span class="comment">/* 填充序言块头部 */</span></span><br><span class="line">    PUT(heap_list + ((<span class="number">2</span> + CLASS_SIZE) * WSIZE), PACK(DSIZE, <span class="number">1</span>));        <span class="comment">/* 填充序言块尾部 */</span></span><br><span class="line">    PUT(heap_list + ((<span class="number">3</span> + CLASS_SIZE) * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));            <span class="comment">/* 结尾块 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩展空闲空间 */</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>见上面画的结构图，在序言块之前放置 20 个空闲链表头指针，剩下的结构与原来完全一样。而扩展堆是在结尾块后进行扩展，因而扩展块操作也与原来相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   扩展heap，传入的是字节数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span>&#123;</span><br><span class="line">    <span class="comment">/* bp总是指向有效载荷 */</span></span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="comment">/* 根据传入字节数的奇偶性，考虑对齐 */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配 */</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置头部和尾部 */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));            <span class="comment">/* 空闲块头 */</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));            <span class="comment">/* 空闲块脚 */</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));    <span class="comment">/* 新结尾块设置*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断相邻块是否是空闲块，进行合并 */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="维护链表"><a href="#维护链表" class="headerlink" title="维护链表"></a>维护链表</h4><p>在知道要请求块的大小后，我们要先根据大小定位到相应大小类的头结点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* search - 找到块大小对应的等价类的序号*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">4</span>; i &lt;= <span class="number">22</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= (<span class="number">1</span> &lt;&lt; i)) <span class="keyword">return</span> i - <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i - <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，头结点位置下标是从 0 开始，所以返回<code>i-4</code>。这里还可以写一个二分查找的形式，但是优化作用不大。(某位博主说的，有兴趣的童鞋可以尝试一下)</p>
<p>找到头结点后，就涉及到双向链表的插入和删除了，下面编写这两个函数</p>
<p>插入函数（insert）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* insert，插入块，将块插到链表头部*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">void</span> *bp)</span>&#123;</span><br><span class="line">    <span class="comment">/* 获取块的大小 */</span></span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="comment">/* 获取空闲链表的头序号*/</span></span><br><span class="line">    <span class="type">int</span> num = search(size);</span><br><span class="line">    <span class="keyword">if</span> (GET_HEAD(num) == <span class="literal">NULL</span>) &#123;            <span class="comment">// 若为空，则直接放入</span></span><br><span class="line">        PUT(heap_list + WSIZE * num, bp);</span><br><span class="line">        PUT(bp, <span class="literal">NULL</span>);                     <span class="comment">//  前驱</span></span><br><span class="line">        PUT((<span class="type">unsigned</span> <span class="type">int</span> *)bp + <span class="number">1</span>, <span class="literal">NULL</span>); <span class="comment">//  后继</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                               <span class="comment">// 不为空，则将块插入链表头</span></span><br><span class="line">        <span class="comment">/* 双向链表连接 */</span></span><br><span class="line">        PUT((<span class="type">unsigned</span> <span class="type">int</span> *)bp + <span class="number">1</span>, GET_HEAD(num));     <span class="comment">// bp的后继放原来的第一个节点</span></span><br><span class="line">        PUT(GET_HEAD(num), bp);                         <span class="comment">// 原来第一个节点的前驱放bp</span></span><br><span class="line">        PUT(bp, <span class="literal">NULL</span>);                                  <span class="comment">// bp的前驱为空</span></span><br><span class="line">        PUT(heap_list + WSIZE * num, bp);               <span class="comment">// 头结点放bp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>insert函数的编写主要注意以下两点：</p>
<ul>
<li>  插入块总是插入到表头</li>
<li>  指针问题要细致考虑。比如：<code>heap_list + WSIZE * num</code>是对应大小类头结点在堆中的位置，而<code>GET_HEAD(num)</code>是大小类头结点存放的第一个块的地址</li>
</ul>
<p>删除函数（delete）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* delete 删除块，将双向链表中的某一个节点删除*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">void</span> *bp)</span>&#123;</span><br><span class="line">    <span class="comment">/* 获取块的大小 */</span></span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="comment">/* 获取空闲链表的头序号*/</span></span><br><span class="line">    <span class="type">int</span> num = search(size);</span><br><span class="line">    <span class="comment">/* 分四种情况 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1.当bp为唯一节点，后继为null，前驱为null</span></span><br><span class="line"><span class="comment">    *  直接将头结点设置为null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (GET_PRE(bp) == <span class="literal">NULL</span> &amp;&amp; GET_SUC(bp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PUT(heap_list + num * WSIZE, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.当bp是最后一个节点</span></span><br><span class="line"><span class="comment">    *  将bp前驱节点的后继设置为null即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (GET_PRE(bp) != <span class="literal">NULL</span> &amp;&amp; GET_SUC(bp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PUT(GET_PRE(bp) + <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3.当bp是第一个节点时</span></span><br><span class="line"><span class="comment">    *  将头结点设置为bp的后继节点即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (GET_PRE(bp) == <span class="literal">NULL</span> &amp;&amp; GET_SUC(bp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PUT(heap_list + num * WSIZE, GET_SUC(bp));</span><br><span class="line">        PUT(GET_SUC(bp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4.当bp是中间节点时</span></span><br><span class="line"><span class="comment">    *  需要将bp的前驱节点和后继节点连接</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PUT(GET_PRE(bp) + <span class="number">1</span>, GET_SUC(bp));</span><br><span class="line">        PUT(GET_SUC(bp), GET_PRE(bp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  考虑四种情况就好，注释写得很详细了</li>
<li>  同样要注意指针的问题。比如：<code>GET_PRE(bp) + 1</code>是<code>bp</code>指向的块的前驱的后继的<strong>位置</strong></li>
</ul>
<h4 id="合并与分割-1"><a href="#合并与分割-1" class="headerlink" title="合并与分割"></a>合并与分割</h4><p>合并操作还是与 Implict Free List 一样，是根据空闲块在堆中位置相邻来合并的，与链表排列无关</p>
<p>合并空闲块（coalesce）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   合并空闲块</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> * bp)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));        <span class="comment">/* 前一块是否分配 */</span></span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));        <span class="comment">/* 后一块是否分配 */</span></span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));                          <span class="comment">/* 当前块大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">// Case 1</span></span><br><span class="line">        insert(bp);</span><br><span class="line">        <span class="keyword">return</span> bp;                                            <span class="comment">/*前后都已分配，直接将空闲块插入链表 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123; <span class="comment">// Case 2</span></span><br><span class="line">        <span class="comment">// 后一块空闲，前一块不空闲</span></span><br><span class="line">        delete(NEXT_BLKP(bp));                               <span class="comment">/* 将后面的块从其链表中删除 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));               <span class="comment">/* 更新新的空闲块大小 */</span></span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));                        <span class="comment">/* 修改空闲块头部 */</span></span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));                        <span class="comment">/* 修改空闲块尾部 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">// Case 3</span></span><br><span class="line">        <span class="comment">// 前一块空闲，后一块不空闲</span></span><br><span class="line">        delete(PREV_BLKP(bp));                               <span class="comment">/* 将其前面的块从链表中删除 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));               <span class="comment">/* 更新新的空闲块大小 */</span></span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));                        <span class="comment">/* 修改空闲块尾部 */</span></span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));             <span class="comment">/* 找到前块空闲块的头部进行修改 */</span></span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// Case 4</span></span><br><span class="line">        <span class="comment">// 前后块均空闲</span></span><br><span class="line">        <span class="comment">/* 将前后两个块都从其链表中删除 */</span></span><br><span class="line">        delete(PREV_BLKP(bp));</span><br><span class="line">        delete(NEXT_BLKP(bp));</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(HDRP(NEXT_BLKP(bp)));  <span class="comment">/* 更新新的空闲块大小 */</span></span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));             <span class="comment">/* 找到前块空闲块的头部进行修改 */</span></span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));             <span class="comment">/* 找到后块空闲块的尾部进行修改 */</span></span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 空闲表准备好后，将其插入合适位置 */</span></span><br><span class="line">    insert(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  coalesce操作与 Implict Free List 几乎相同</li>
<li>  额外的操作就是合并前要将前后的空闲块从它的原链表中删除，合并完成后要将新的空闲块插入对应的空闲链表中</li>
</ul>
<p>分离空闲块（place）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* place 分离空闲块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> asize)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> block_size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="comment">/* 将要分配ptr，因此将ptr指向的块从空闲链表中删除*/</span></span><br><span class="line">    delete(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((block_size - asize) &gt;= (<span class="number">2</span> * DSIZE)) &#123; <span class="comment">// 需要截断</span></span><br><span class="line">        PUT(HDRP(ptr), PACK(asize, <span class="number">1</span>));        <span class="comment">// 修改头部</span></span><br><span class="line">        PUT(FTRP(ptr), PACK(asize, <span class="number">1</span>));        <span class="comment">// 沿着刚修改的头部，找到重新定位后的尾部</span></span><br><span class="line">        ptr = NEXT_BLKP(ptr);                  <span class="comment">// 沿着刚修改的头部，找到未分配块的有效载荷</span></span><br><span class="line">        PUT(HDRP(ptr), PACK(block_size - asize, <span class="number">0</span>));   <span class="comment">// 修改空闲块头部的分配大小</span></span><br><span class="line">        PUT(FTRP(ptr), PACK(block_size - asize, <span class="number">0</span>));   <span class="comment">// 修改空闲块尾部的分配大小</span></span><br><span class="line">        <span class="comment">/* 将分离出来的空闲块加入空闲链表中 */</span></span><br><span class="line">        insert(ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不需要截断，修改头部尾部即可</span></span><br><span class="line">        PUT(HDRP(ptr), PACK(block_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(ptr), PACK(block_size, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分离空闲块也只是加入了将分离出来的空闲块插入相应空闲链表的操作</li>
</ul>
<h4 id="分配块-1"><a href="#分配块-1" class="headerlink" title="分配块"></a>分配块</h4><p>分配策略：</p>
<ul>
<li>先从对应的大小类的空闲链表中查找</li>
<li>如果找不到，则到下一个更大的大小类查找</li>
<li>如果都找不到，则扩展堆</li>
</ul>
<p>分配策略（first_fit）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = search(size);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>* bp;</span><br><span class="line">    <span class="comment">/* 如果找不到合适的块，则搜索下一个更大的空闲链表 */</span></span><br><span class="line">    <span class="keyword">while</span> (num &lt; CLASS_SIZE) &#123;</span><br><span class="line">        bp = GET_HEAD(num);</span><br><span class="line">        <span class="comment">/* 如果bp在当前空闲链表不为空，则继续寻找*/</span></span><br><span class="line">        <span class="keyword">while</span> (bp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (GET_SIZE(HDRP(bp)) &gt;= size) <span class="keyword">return</span> (<span class="type">void</span> *)bp;</span><br><span class="line">            bp = GET_SUC(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 否则在下一个空闲链表中进行寻找 */</span></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配（malloc）：与implict_list一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> asize;</span><br><span class="line">    <span class="type">size_t</span> extend_size;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE) asize = <span class="number">2</span> * DSIZE; <span class="comment">// 至少16字节</span></span><br><span class="line">    <span class="keyword">else</span> asize = DSIZE * ((size + (DSIZE) + (DSIZE - <span class="number">1</span>)) / DSIZE); <span class="comment">// 向上与8字节对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找合适的空闲块</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找不到则扩展堆</span></span><br><span class="line">    extend_size = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extend_size / WSIZE)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><img src="20230513133638.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于本人对c语言掌握的并不好，因此大部分代码都是在参考各位大佬的思路完成的，不过也通过本次实验对内存动态分配的思想有了进一步的认识。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://blog.rayzhang.top/2022/05/25/csapp-malloclab/index.html#%E5%87%86%E5%A4%87">CS:APP Malloc Lab 实验 | Ray’s Blog (rayzhang.top)</a></p>
<p><a target="_blank" rel="noopener" href="https://wdxtub.com/csapp/thick-csapp-lab-6/2016/04/16/">【读厚 CSAPP】VI Malloc Lab | 小土刀 2.0 (wdxtub.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/496366818">CSAPP | Lab8-Malloc Lab 深入解析 - 知乎 (zhihu.com)</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">wenwenka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/13/CsApp-%E2%80%94%E2%80%94-mallocLab/">http://example.com/2023/05/13/CsApp-%E2%80%94%E2%80%94-mallocLab/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">温温卡的blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CsApp/">CsApp</a></div><div class="post_share"><div class="social-share" data-image="/2023/05/13/CsApp-%E2%80%94%E2%80%94-mallocLab/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/05/13/%E5%AE%8C%E6%88%90%E5%A4%A7%E8%AE%BA%E6%96%87/"><img class="next-cover" src="/img/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">完成大论文</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/" title="CsApp —— Attack Lab"><img class="cover" src="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-18</div><div class="title">CsApp —— Attack Lab</div></div></a></div><div><a href="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/" title="CsApp —— Cache Lab"><img class="cover" src="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-21</div><div class="title">CsApp —— Cache Lab</div></div></a></div><div><a href="/2023/01/09/CsApp-%E2%80%94%E2%80%94-Data-Lab/" title="CsApp —— Data Lab"><img class="cover" src="/2023/01/09/CsApp-%E2%80%94%E2%80%94-Data-Lab/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-09</div><div class="title">CsApp —— Data Lab</div></div></a></div><div><a href="/2023/03/21/CsApp-%E2%80%94%E2%80%94-ShellLab/" title="CsApp —— Shell Lab"><img class="cover" src="/2023/03/21/CsApp-%E2%80%94%E2%80%94-ShellLab/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-21</div><div class="title">CsApp —— Shell Lab</div></div></a></div><div><a href="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/" title="CsApp —— Bomb Lab"><img class="cover" src="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-10</div><div class="title">CsApp —— Bomb Lab</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wenwenka</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wenwenka" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/wu290063155@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.1.</span> <span class="toc-text">作业区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">测试程序：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="toc-number">2.</span> <span class="toc-text">实验内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E8%A6%81%E6%B1%82"><span class="toc-number">2.1.</span> <span class="toc-text">作业要求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BD%93%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">主体函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%99%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">内存检查器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%90%86%E8%A7%A3"><span class="toc-number">2.1.3.</span> <span class="toc-text">示例理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E4%B8%8E%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">策略与代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">隐式空闲链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E5%9D%97%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">空闲块的组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%8E%E5%88%86%E5%89%B2"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">合并与分割</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A0%86"><span class="toc-number">2.2.1.2.1.</span> <span class="toc-text">初始化堆</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BE%E7%BD%AE%E7%AD%96%E7%95%A5"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">放置策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%9D%97"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">分配块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%88%86%E9%85%8D%E5%9D%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">重分配块的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.1.6.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Segregated-Free-Lists-%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">Segregated Free Lists 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">定义宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%B1%BB%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">大小类设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">结构建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">维护链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%8E%E5%88%86%E5%89%B2-1"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">合并与分割</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%9D%97-1"><span class="toc-number">2.2.2.6.</span> <span class="toc-text">分配块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-number">2.2.2.7.</span> <span class="toc-text">测试</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/13/CsApp-%E2%80%94%E2%80%94-mallocLab/" title="CsApp —— Malloc Lab"><img src="/2023/05/13/CsApp-%E2%80%94%E2%80%94-mallocLab/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CsApp —— Malloc Lab"/></a><div class="content"><a class="title" href="/2023/05/13/CsApp-%E2%80%94%E2%80%94-mallocLab/" title="CsApp —— Malloc Lab">CsApp —— Malloc Lab</a><time datetime="2023-05-13T10:36:00.000Z" title="发表于 2023-05-13 18:36:00">2023-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/13/%E5%AE%8C%E6%88%90%E5%A4%A7%E8%AE%BA%E6%96%87/" title="完成大论文"><img src="/img/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="完成大论文"/></a><div class="content"><a class="title" href="/2023/05/13/%E5%AE%8C%E6%88%90%E5%A4%A7%E8%AE%BA%E6%96%87/" title="完成大论文">完成大论文</a><time datetime="2023-05-13T10:20:31.000Z" title="发表于 2023-05-13 18:20:31">2023-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/21/CsApp-%E2%80%94%E2%80%94-ShellLab/" title="CsApp —— Shell Lab"><img src="/2023/03/21/CsApp-%E2%80%94%E2%80%94-ShellLab/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CsApp —— Shell Lab"/></a><div class="content"><a class="title" href="/2023/03/21/CsApp-%E2%80%94%E2%80%94-ShellLab/" title="CsApp —— Shell Lab">CsApp —— Shell Lab</a><time datetime="2023-03-21T14:45:00.000Z" title="发表于 2023-03-21 22:45:00">2023-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/" title="CsApp —— Cache Lab"><img src="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CsApp —— Cache Lab"/></a><div class="content"><a class="title" href="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/" title="CsApp —— Cache Lab">CsApp —— Cache Lab</a><time datetime="2023-01-21T14:42:00.000Z" title="发表于 2023-01-21 22:42:00">2023-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/" title="CsApp —— Attack Lab"><img src="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CsApp —— Attack Lab"/></a><div class="content"><a class="title" href="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/" title="CsApp —— Attack Lab">CsApp —— Attack Lab</a><time datetime="2023-01-18T14:07:00.000Z" title="发表于 2023-01-18 22:07:00">2023-01-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wenwenka</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>