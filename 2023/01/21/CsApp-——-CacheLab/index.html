<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CsApp —— Cache Lab | 温温卡的blog</title><meta name="author" content="wenwenka,wu290063155@gmail.com"><meta name="copyright" content="wenwenka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介Cache Lab 共分为两部分，PartA需要模拟cache运行的过程，就是模拟cache的行为。PartB是一个矩阵转置，给出了三种数据范围，我们的任务就是尽可能提高高速缓存的命中率，系统会根据我们的miss，hit，eviction这三个值的大小进行打分。具体请参考cache lab的文档 cachelab.dvi (cmu.edu)实验开始前可以参考该ppt的内容，回顾了书本的内容，并">
<meta property="og:type" content="article">
<meta property="og:title" content="CsApp —— Cache Lab">
<meta property="og:url" content="http://example.com/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/index.html">
<meta property="og:site_name" content="温温卡的blog">
<meta property="og:description" content="简介Cache Lab 共分为两部分，PartA需要模拟cache运行的过程，就是模拟cache的行为。PartB是一个矩阵转置，给出了三种数据范围，我们的任务就是尽可能提高高速缓存的命中率，系统会根据我们的miss，hit，eviction这三个值的大小进行打分。具体请参考cache lab的文档 cachelab.dvi (cmu.edu)实验开始前可以参考该ppt的内容，回顾了书本的内容，并">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/cover.jpg">
<meta property="article:published_time" content="2023-01-21T14:42:00.000Z">
<meta property="article:modified_time" content="2023-02-02T14:50:40.328Z">
<meta property="article:author" content="wenwenka">
<meta property="article:tag" content="CsApp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/cover.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CsApp —— Cache Lab',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-02 22:50:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/cover.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">温温卡的blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CsApp —— Cache Lab</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-21T14:42:00.000Z" title="发表于 2023-01-21 22:42:00">2023-01-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-02T14:50:40.328Z" title="更新于 2023-02-02 22:50:40">2023-02-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CsApp —— Cache Lab"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Cache Lab 共分为两部分，PartA需要模拟cache运行的过程，就是模拟cache的行为。PartB是一个矩阵转置，给出了三种数据范围，我们的任务就是尽可能提高高速缓存的命中率，系统会根据我们的miss，hit，eviction这三个值的大小进行打分。<br>具体请参考cache lab的文档 <a target="_blank" rel="noopener" href="http://www.csapp.cs.cmu.edu/3e/cachelab.pdf">cachelab.dvi (cmu.edu)</a><br>实验开始前可以参考该ppt的内容，回顾了书本的内容，并对实验部分也给予一定的引导：<br><a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">实验先导部分)</a></p>
<p>在开始前，需要执行以下的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install valgrind 内存泄漏检测工具</span></span><br><span class="line">sudo apt install valgrind</span><br><span class="line">valgrind --version</span><br><span class="line"><span class="comment"># make</span></span><br><span class="line">make clean</span><br><span class="line">make </span><br></pre></td></tr></table></figure>
<h1 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>本部分的要求，是告诉我们模拟缓存的行为不是真实缓存，内存的数据不用存储，不用进行块便宜，地址里的b因此不太重要，只要能计算hits、miss、evictions的值即可。然后就是模拟器需要适用于不同的（s, b, E），同时给出运行时间。最后就是要求我们使用LRU的策略进行替换。</p>
<p>本题需要做的就是用C语言写一个程序csim.c，这个程序的表现需要和csim-ref一样，也就是模仿一个cache的行为，不用模仿全部行为，只需要让csim.c能对S（Store）、L（Load）、M（Modify）这三种类型的地址操作，表现出MISS、HIT、EVICTION即可。</p>
<p>这里需要再考量的是，如何实现LRU。LRU即最近最少访问，大家应该在学习操作系统的时候接触过这个概念。这个算法需要解决两个问题：</p>
<ol>
<li>用什么代表某一个行的最近访问次数</li>
<li>怎么找到这个最近最少访问的行</li>
</ol>
<p>对于1，我们可以维护一个时间变量T，每次访存了这一行就更新，那么T最小或最大的【可见具体实现的逻辑】就是最近最少访问的。</p>
<p>对于2，我们可以采取直接遍历做min求最小，或者使用hash和链表，但是在缓存中需要越快越好，且不能太占空间，因此用直接遍历的方法是可行的。</p>
<h3 id="自带函数介绍"><a href="#自带函数介绍" class="headerlink" title="自带函数介绍"></a>自带函数介绍</h3><p>在先导ppt里给出了几个函数的介绍：</p>
<ol>
<li>getplot()</li>
</ol>
<p>如果函数声明丢失，则在Unix命令行上自动解析元素，通常在循环中调用以检索参数，它的返回值存储在局部变量中。 即该函数是个命令行解析工具<br>使用该函数得加上以下两个头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>fscanf()</li>
</ol>
<p>读入测试文件的，ppt也给出了示例代码。</p>
<ol start="3">
<li>Malloc/free</li>
</ol>
<p>分配和释放内存空间的函数</p>
<p>Some_pointer_you_malloced = malloc(sizeof(int));<br>Free(some_pointer_you_malloced);</p>
<p>分配了内存用完的时候记得释放，还有不要释放没有分配的内存。</p>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="1-定义数据结构"><a href="#1-定义数据结构" class="headerlink" title="1.定义数据结构"></a>1.定义数据结构</h3><p>在ppt里，给出了Part A需要用到的结构体：<br><img src="Pasted_image_20230118133632.png"></p>
<p>讲义告诉我们，不需要处理B，只需要有有效位、标记位和时间戳即可。因此我们可以写出以下结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_line</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> valid; <span class="comment">// 有效位</span></span><br><span class="line">	<span class="type">int</span> tag;   <span class="comment">// 标记位</span></span><br><span class="line">	<span class="type">int</span> stamp; <span class="comment">// 时间戳</span></span><br><span class="line">&#125; Cache_line;</span><br></pre></td></tr></table></figure>

<p>然后我们可以再定义Cache结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> S;</span><br><span class="line">	<span class="type">int</span> E;</span><br><span class="line">	<span class="type">int</span> B;</span><br><span class="line">	Cache_line **line;</span><br><span class="line">&#125; Cache;</span><br></pre></td></tr></table></figure>

<h3 id="2-初始化Cache"><a href="#2-初始化Cache" class="headerlink" title="2.初始化Cache"></a>2.初始化Cache</h3><p>定义一个cache[S][E]大小的二维数组（using malloc），这样cache就模拟好了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init_Cache</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> E, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> S = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">    <span class="type">int</span> B = <span class="number">1</span> &lt;&lt; b;</span><br><span class="line">    Cache *cache = (Cache *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cache));</span><br><span class="line">    cache-&gt;S = S;</span><br><span class="line">    cache-&gt;E = E;</span><br><span class="line">    cache-&gt;B = B;</span><br><span class="line">    cache-&gt;line = (Cache_line **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cache_line *) * S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; S;i++) &#123;</span><br><span class="line">        cache-&gt;line[i] = (Cache_line *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cache_line) * E);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; E; j++) &#123;</span><br><span class="line">            cache-&gt;line[i][j].valid = <span class="number">0</span>; <span class="comment">// 初始时，高速缓存为空</span></span><br><span class="line">            cache-&gt;line[i][j].tag = <span class="number">0xffffffff</span>;</span><br><span class="line">            cache-&gt;line[i][j].stamp = <span class="number">0</span>; <span class="comment">// 时间戳初始设置为0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面cache-&gt;line[i]的初始化，刚开始没理解，写成了sizeof(Cache_line *)，导致整个函数在某个得分点报错，虽然不知道其他是怎么过的，后来仔细比对才发现是这个地方的问题。<br>并且又巩固了一下gdb的一些操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 断点函数中的某一行 32为行数</span></span><br><span class="line">b xx.c:32</span><br><span class="line"><span class="comment"># 从c语言层面往下执行</span></span><br><span class="line">n </span><br></pre></td></tr></table></figure>

<p>有初始化，动态分配空间，就应该考虑到释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_Cache</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> S = cache-&gt;S;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">free</span>(cache-&gt;line[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(cache-&gt;line);</span><br><span class="line">	<span class="built_in">free</span>(cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-LRU时间戳实现"><a href="#3-LRU时间戳实现" class="headerlink" title="3. LRU时间戳实现"></a>3. LRU时间戳实现</h3><p>这里的逻辑是，有缓存的时间戳要每次增加，如果被访问到了，就将当前的时间戳置为0，因此时间戳越大则表示该行最后访问的时间越久远。下面是缓存更新的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LRU更新</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> op_s, <span class="type">int</span> op_tag)</span> &#123;</span><br><span class="line">    cache-&gt;line[op_s][i].valid = <span class="number">1</span>;</span><br><span class="line">    cache-&gt;line[op_s][i].tag = op_tag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; cache-&gt;E; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache-&gt;line[op_s][k].valid == <span class="number">1</span>) &#123;</span><br><span class="line">            cache-&gt;line[op_s][k].stamp++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache-&gt;line[op_s][i].stamp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在找到要进行的操作行后调用（无论是不命中还是命中，还是驱逐后）。前两行是对有效位和标志位的设置，与时间戳无关，主要关注后几行：</p>
<ul>
<li>  遍历组中每一行，并将它们的值加1，也就是说每一行在进行一次操作后时间戳都会变大，表示它离最后操作的时间变久</li>
<li>  将本次操作的行时间戳设置为最小，也就是0</li>
</ul>
<p>因此，每次只需要找到时间戳最大的行进行替换即可，就是找最大值，写法也比较常规：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到需要替换的E</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_LRU</span><span class="params">(<span class="type">int</span> op_s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_stamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; cache-&gt;E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache-&gt;line[op_s][i].stamp &gt; max_stamp) &#123;</span><br><span class="line">            max_stamp = cache-&gt;line[op_s][i].stamp;</span><br><span class="line">            max_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-缓存搜索及更新"><a href="#4-缓存搜索及更新" class="headerlink" title="4. 缓存搜索及更新"></a>4. 缓存搜索及更新</h3><p>在得知要操作的op_s以及标志位op_tag后，判断是miss还是hit，或者是应该eviction调用find_LRU。<br>先判断是miss还是hit：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断缓存是否命中</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_index</span><span class="params">(<span class="type">int</span> op_s, <span class="type">int</span> op_tag)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache-&gt;line[op_s][i].valid &amp;&amp; cache-&gt;line[op_s][i].tag == op_tag) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历所有行，如果某一行有效，且标志位相同，则<code>hit</code>，返回该索引。否则，<code>miss</code>，返回 -1。当接收到-1后，有两种情况：</p>
<ul>
<li>  冷不命中。组中有空行，只不过还未操作过，有效位为0，找到这个空行即可</li>
<li>  所有行都满了。那么就要用到上面得 LRU 进行选择驱逐</li>
</ul>
<p>所以，设计一个判满的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断缓存是否已满</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_full</span><span class="params">(<span class="type">int</span> op_s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; cache-&gt;E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache-&gt;line[op_s][i].valid) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当扫描完成后，得到对应行的索引值，就可以调用缓存更新函数进行更新了。整体调用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描 + 缓存更新</span></span><br><span class="line"><span class="comment">// verbose指代是否打印详细信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_info</span><span class="params">(<span class="type">int</span> op_tag, <span class="type">int</span> op_s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = get_index(op_s, op_tag);</span><br><span class="line">    <span class="comment">// 发生miss，无法命中</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">        miss_count++;</span><br><span class="line">        <span class="keyword">if</span> (verbose) <span class="built_in">printf</span>(<span class="string">&quot;miss &quot;</span>);</span><br><span class="line">        index = is_full(op_s);</span><br><span class="line">        <span class="comment">// 如果缓存已满，则需要使用LRU更新</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">            eviction_count++;</span><br><span class="line">            <span class="keyword">if</span> (verbose) <span class="built_in">printf</span>(<span class="string">&quot;eviction&quot;</span>);</span><br><span class="line">            index = find_LRU(op_s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不管是cold miss，还是LRU替换后，都需要update</span></span><br><span class="line">        update(index, op_s, op_tag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hit 缓存命中</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        hit_count++;</span><br><span class="line">        <span class="keyword">if</span> (verbose) <span class="built_in">printf</span>(<span class="string">&quot;hit&quot;</span>);</span><br><span class="line">        update(index, op_s, op_tag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Part A的核心部分函数就编写完了，下面的内容与题目相关。</p>
<h3 id="5-指令解析"><a href="#5-指令解析" class="headerlink" title="5. 指令解析"></a>5. 指令解析</h3><p>设计的数据结构解决了对 Cache 的操作问题，LRU 时间戳的实现解决了核心的驱逐问题，缓存扫描解决了对块中哪一列进行操作的问题，而应该对哪一块进行操作呢？接下来要解决的就是指令的解析问题了。<br>输入数据为<code>[space]operation address, size</code>的形式，<code>operation</code>很容易获取，重要的是从<code>address</code>中分别获取我们需要的<code>s</code>和<code>tag</code>，<code>address</code>结构如下：<br><img src="Pasted_image_20230118151201.png"></p>
<p>address是一个无符号数。<br>tag因为处于最右端，很容易得到，将address右移(b + s)位即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> op_tag = address &gt;&gt; (b + s);</span><br></pre></td></tr></table></figure>
<p>获取s，，可以先将address右移b位，然后再将s左边的部分用掩膜盖掉即可，掩膜可以使用无符号的0xffffffff右移32-s位得到，因为C中右移默认是算术右移，因此得用无符号的0xff…才可得到合适的掩膜:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> op_s = (address &gt;&gt; b) &amp; ((<span class="type">unsigned</span>) (<span class="number">-1</span>) &gt;&gt; (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span>) - s));</span><br></pre></td></tr></table></figure>

<p>由于数据读写对于本模拟器而言是没有区别的，因此不同的指令对应的知识Cache更新次数的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_trace</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> E, <span class="type">int</span> b)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    FILE *pFile;</span><br><span class="line">    pFile = fopen(t, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pFile == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> identifier;</span><br><span class="line">    <span class="type">unsigned</span> address;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// Reading lines like &quot; M 20,1&quot; or &quot;L 19,3&quot;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(pFile, <span class="string">&quot; %c %x,%d&quot;</span>, &amp;identifier, &amp;address, &amp;size) &gt; <span class="number">0</span>) <span class="comment">// I读不进来,忽略---size没啥用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//想办法先得到标记位和组序号</span></span><br><span class="line">        <span class="type">int</span> op_tag = address &gt;&gt; (s + b);</span><br><span class="line">        <span class="type">int</span> op_s = (address &gt;&gt; b) &amp; ((<span class="type">unsigned</span>)(<span class="number">-1</span>) &gt;&gt; (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span>) - s));</span><br><span class="line">        <span class="keyword">switch</span> (identifier)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="comment">//一次存储一次加载</span></span><br><span class="line">            update_info(op_tag, op_s);</span><br><span class="line">            update_info(op_tag, op_s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            update_info(op_tag, op_s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            update_info(op_tag, op_s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>update_info</code>就是对 Cache 进行更新的函数，前面已经讲解。如果指令是<code>M</code>则一次存储一次加载，总共更新两次，其他指令只用更新一次，而<code>I</code>无需考虑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_help</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;** A Cache Simulator by Deconx\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Options:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-h Print this help message.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-v Optional verbose flag.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-s &lt;num&gt; Number of set index bits.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-E &lt;num&gt; Number of lines per set.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-b &lt;num&gt; Number of block offset bits.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-t &lt;file&gt; Trace file.\n\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Examples:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;linux&gt; ./csim -s 4 -E 1 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;linux&gt; ./csim -v -s 8 -E 2 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> opt;</span><br><span class="line">    <span class="type">int</span> s, E, b;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * s:S=2^s是组的个数</span></span><br><span class="line"><span class="comment">     * E:每组中有多少行</span></span><br><span class="line"><span class="comment">     * b:B=2^b每个缓冲块的字节数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">-1</span> != (opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            print_help();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            s = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            E = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            b = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(t, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            print_help();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Init_Cache(s, E, b); <span class="comment">//初始化一个cache</span></span><br><span class="line">    get_trace(s, E, b);</span><br><span class="line">    free_Cache();</span><br><span class="line">    printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功通过part A:<br><img src="Pasted_image_20230118164120.png"></p>
<h1 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>该部分是在trans.c中编写矩阵转置的函数，在一个s=5，E=1，b=5的缓存中进行读写，使得miss的次数最少，测试矩阵的参数以及miss次数对应的分数如下：<br><img src="Pasted_image_20230120205504.png"></p>
<p>由s=5,b=5，即可知我们总共有32个set，每组1行，每个block大小是32bytes，如图：<br><img src="Pasted_image_20230120210103.png"></p>
<h2 id="32-×-32"><a href="#32-×-32" class="headerlink" title="32 × 32"></a>32 × 32</h2><p><strong>开始之前，我们得先了解一下何为分块，为什么分块?</strong></p>
<p>题目给出了未优化，直接转置的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trans_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            tmp = A[i][j];</span><br><span class="line">            B[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们会按行优先读取 <code>A</code> 矩阵，然后一列一列地写入 <code>B</code> 矩阵。</p>
<p><img src="Pasted_image_20230120210616.png"></p>
<p>以第1行为例，在从内存读 <code>A[0][0]</code> 的时候，除了 <code>A[0][0]</code> 被加载到缓存中，它之后的 <code>A[0][1]---A[0][7]</code> 也会被加载进缓存。</p>
<p>但是内容写入 <code>B</code> 矩阵的时候是一列一列地写入，在列上相邻的元素不在一个内存块上，这样每次写入都不命中缓存。并且一列写完之后再返回，原来的缓存可能被覆盖了，这样就又会不命中。</p>
<p>当前n为32，每次缓存能够存入A的8个元素，因此A的一行能够写入4组缓存，总共set有32组，所以整个缓存能够存储8行矩阵A，也即矩阵A的1/4，每隔8行，就会在缓存中覆盖之前的记录。下图中的0,1代表的应该是一个set。而A与B的地址是相连的，因此，如果A与B访问的是同一个位置的元素，那么缓存将会被覆盖。</p>
<p><img src="Pasted_image_20230120211522.png"></p>
<p>对于A，我们只需分析block造成的影响，一个block能够容纳8个int，因此A的每一行会有32/8=4次不命中；而对于B，每一列有32次不命中，由此算出总的不命中的次数为4×32 + 32 × 32 = 1152。跑一下结果如下：</p>
<p><img src="Pasted_image_20230120212330.png"></p>
<p>可以发现miss数为1184，比预想的多了32次。</p>
<p>根据提示，我们需要使用分块技术来提升缓存命中率。在进行分块前，让我们先探讨一下，A的读取与B的写入在缓存中是否会发生冲突：</p>
<ul>
<li>如果i == j，因为对应位置相同，对应到缓存的行应该也会相同，所以会冲突</li>
<li>如果i != j，A会缓存i行的内容，而B会缓存j行的内容，两者理论上是不会出现在同一组缓存中的。</li>
</ul>
<p>如果我们暂时忽略对角线的影响，假设A和B是不会发生冲突的，由于cache在行上最多可以存8行，列上最多存8个元素，因此，我们可以选择分块的大小为8×8。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> trans_32_desc[] = <span class="string">&quot;32 simple transpose&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_32</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; M;j += <span class="number">8</span>) &#123;</span><br><span class="line">	        <span class="comment">// 在此进行分块</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> n = i; n &lt; i + <span class="number">8</span>;n++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> m = j;m &lt; j + <span class="number">8</span>;m++) &#123;</span><br><span class="line">                    B[m][n] = A[n][m];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上分块的代码分析得出，对于每个分块，A的每一行的第一个元素不会命中，所以对A来说有8次，还得加上对角线的7次，共15次；对于B来说，B载入的第一列的所有元素也均不会命中，后面的元素才会在缓存命中，因此也为8次<br>所以计算的miss次数应为 15 × 16 + 8 × 16 = 368次</p>
<p>跑完结果如下：<br><img src="Pasted_image_20230120223747.png"></p>
<p>miss次数与我们预估的比较接近，但是少了一点。</p>
<p>题目又给了我们提示，让我们能够使用12个局部变量存储数据，所以我们能够将A的分块的每一行，即8个元素，使用局部变量进行存储。能够保证A的对角线元素不会被覆盖，但无法保证B的对角线元素被覆盖。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> trans_32_uprolling_desc[] = <span class="string">&quot;32 uprolling transpose&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_32_uprolling</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; M;j += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i + <span class="number">8</span>;k++) &#123;</span><br><span class="line">                <span class="comment">// 刚开始A的第一个不命中，后面的元素命中，对角线也能保存</span></span><br><span class="line">                <span class="type">int</span> tmp_1 = A[k][j];</span><br><span class="line">                <span class="type">int</span> tmp_2 = A[k][j + <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> tmp_3 = A[k][j + <span class="number">2</span>];</span><br><span class="line">                <span class="type">int</span> tmp_4 = A[k][j + <span class="number">3</span>];</span><br><span class="line">                <span class="type">int</span> tmp_5 = A[k][j + <span class="number">4</span>];</span><br><span class="line">                <span class="type">int</span> tmp_6 = A[k][j + <span class="number">5</span>];</span><br><span class="line">                <span class="type">int</span> tmp_7 = A[k][j + <span class="number">6</span>];</span><br><span class="line">                <span class="type">int</span> tmp_8 = A[k][j + <span class="number">7</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当前第i列的元素不会命中，后面的元素会进入缓存，但对角线的元素仍可能被覆盖</span></span><br><span class="line">                B[j][k] = tmp_1;</span><br><span class="line">                B[j + <span class="number">1</span>][k] = tmp_2;</span><br><span class="line">                B[j + <span class="number">2</span>][k] = tmp_3;</span><br><span class="line">                B[j + <span class="number">3</span>][k] = tmp_4;</span><br><span class="line">                B[j + <span class="number">4</span>][k] = tmp_5;</span><br><span class="line">                B[j + <span class="number">5</span>][k] = tmp_6;</span><br><span class="line">                B[j + <span class="number">6</span>][k] = tmp_7;</span><br><span class="line">                B[j + <span class="number">7</span>][k] = tmp_8;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img src="Pasted_image_20230120230558.png"></p>
<p>miss 小于300，达到要求</p>
<h2 id="64-×-64"><a href="#64-×-64" class="headerlink" title="64 × 64"></a>64 × 64</h2><p>由于矩阵变大了，现在每4行就会发生矩阵覆盖的情况，如果我们按照4×4的分块，跑一下结果，看看会是如何：<br><img src="Pasted_image_20230120231513.png"></p>
<p>发现miss次数有1700，距离1300还是差了很多的。</p>
<p>借鉴相关博主的经验，发现还是得考虑8 × 8的分块，由于仍存在每4行就会占满一个缓存的问题，所以需要将8 × 8的分块的内部分成4个4 × 4的小分块分别处理：</p>
<ul>
<li>  第一步，将<code>A</code>的左上和右上一次性复制给<code>B</code></li>
<li>  第二步，用本地变量把<code>B</code>的右上角存储下来</li>
<li>  第三步，将<code>A</code>的左下复制给<code>B</code>的右上</li>
<li>  第四步，利用上述存储<code>B</code>的右上角的本地变量，把<code>A</code>的右上复制给<code>B</code>的左下</li>
<li>  第五步，把<code>A</code>的右下复制给<code>B</code>的右下</li>
</ul>
<p>这里B因为是转置后的，所以如果A的某个元素为i行j列，B对应的应为j行i列（刚开始没注意这个，总觉得怪怪的，后面理解了，就还好）</p>
<p>这里直接搬运博主画的图了：</p>
<p><strong>这里的<code>A</code>和<code>B</code>均表示两个矩阵中的 8 × 8 块</strong></p>
<p><strong>第 1 步：</strong></p>
<p><img src="Pasted_image_20230121113417.png"></p>
<p>此时<code>B</code>的前 4 行就在缓存中了，接下来考虑利用这个缓存 。可以看到，为了利用<code>A</code>的缓存，第 2 块放置的位置实际上是错的，接下来就用本地变量保存<code>B</code>中第2块的内容</p>
<p><strong>第 2 步：</strong></p>
<p>用本地变量把<code>B</code>的第2块存储下来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; j + <span class="number">4</span>; k++)&#123;</span><br><span class="line">	a_0 = B[k][i + <span class="number">4</span>];</span><br><span class="line">    a_1 = B[k][i + <span class="number">5</span>];</span><br><span class="line">    a_2 = B[k][i + <span class="number">6</span>];</span><br><span class="line">    a_3 = B[k][i + <span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 3 步：</strong></p>
<p>现在缓存中还是存着<code>B</code>中上两块的内容，所以将<code>A</code>的第3块内容复制给它</p>
<p><img src="Pasted_image_20230121113625.png"></p>
<p><strong>第 4/5 步：</strong></p>
<p>现在缓存已经利用到极致了，可以开辟<code>B</code>的下面两块了</p>
<p><img src="Pasted_image_20230121113720.png"></p>
<p>这样就实现了转置，且消除了同一行中的冲突，具体的diamagnetic如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trans_64</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; M; j += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="comment">// 4 * 4分块</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i;k &lt; i + <span class="number">4</span>;k++) &#123;</span><br><span class="line">                <span class="comment">// 得到A的第1，2块</span></span><br><span class="line">                a_0 = A[k][j];</span><br><span class="line">                a_1 = A[k][j + <span class="number">1</span>];</span><br><span class="line">                a_2 = A[k][j + <span class="number">2</span>];</span><br><span class="line">                a_3 = A[k][j + <span class="number">3</span>];</span><br><span class="line">                a_4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">                a_5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">                a_6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">                a_7 = A[k][j + <span class="number">7</span>];</span><br><span class="line">  </span><br><span class="line">                <span class="comment">// 将局部变量复制给B的第1，2块</span></span><br><span class="line">                B[j][k] = a_0;</span><br><span class="line">                B[j + <span class="number">1</span>][k] = a_1;</span><br><span class="line">                B[j + <span class="number">2</span>][k] = a_2;</span><br><span class="line">                B[j + <span class="number">3</span>][k] = a_3;</span><br><span class="line">                B[j][k + <span class="number">4</span>] = a_4;</span><br><span class="line">                B[j + <span class="number">1</span>][k + <span class="number">4</span>] = a_5;</span><br><span class="line">                B[j + <span class="number">2</span>][k + <span class="number">4</span>] = a_6;</span><br><span class="line">                B[j + <span class="number">3</span>][k + <span class="number">4</span>] = a_7;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j;k &lt; j + <span class="number">4</span>;k++) &#123;</span><br><span class="line">                <span class="comment">// 将B的第2块保存</span></span><br><span class="line">                a_0 = B[k][i + <span class="number">4</span>];</span><br><span class="line">                a_1 = B[k][i + <span class="number">5</span>];</span><br><span class="line">                a_2 = B[k][i + <span class="number">6</span>];</span><br><span class="line">                a_3 = B[k][i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 保存A的第3块</span></span><br><span class="line">                a_4 = A[i + <span class="number">4</span>][k];</span><br><span class="line">                a_5 = A[i + <span class="number">5</span>][k];</span><br><span class="line">                a_6 = A[i + <span class="number">6</span>][k];</span><br><span class="line">                a_7 = A[i + <span class="number">7</span>][k];</span><br><span class="line">  </span><br><span class="line">                <span class="comment">// 将A的第3块复制到B的第2块</span></span><br><span class="line">                B[k][i + <span class="number">4</span>] = a_4;</span><br><span class="line">                B[k][i + <span class="number">5</span>] = a_5;</span><br><span class="line">                B[k][i + <span class="number">6</span>] = a_6;</span><br><span class="line">                B[k][i + <span class="number">7</span>] = a_7;</span><br><span class="line">  </span><br><span class="line">                <span class="comment">// 将B的第2块复制到B的第3块</span></span><br><span class="line">                B[k + <span class="number">4</span>][i] = a_0;</span><br><span class="line">                B[k + <span class="number">4</span>][i + <span class="number">1</span>] = a_1;</span><br><span class="line">                B[k + <span class="number">4</span>][i + <span class="number">2</span>] = a_2;</span><br><span class="line">                B[k + <span class="number">4</span>][i + <span class="number">3</span>] = a_3;</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">4</span>;k &lt; i + <span class="number">8</span>;k++) &#123;</span><br><span class="line">                <span class="comment">// 使用分块技术，将A的第4块复制给B的第4块</span></span><br><span class="line">                a_4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">                a_5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">                a_6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">                a_7 = A[k][j + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                B[j + <span class="number">4</span>][k] = a_4;</span><br><span class="line">                B[j + <span class="number">5</span>][k] = a_5;</span><br><span class="line">                B[j + <span class="number">6</span>][k] = a_6;</span><br><span class="line">                B[j + <span class="number">7</span>][k] = a_7;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，至此miss降低到1228。<br><img src="Pasted_image_20230121121006.png"></p>
<h2 id="61-×-67"><a href="#61-×-67" class="headerlink" title="61 × 67"></a>61 × 67</h2><p>本题，依然使用分块处理，使用16 * 16：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> trans_61_67_desc[] = <span class="string">&quot;61 * 67 transpose&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_61_67</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i += <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; M;j += <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = i; m &lt; i + <span class="number">16</span> &amp;&amp; m &lt; N;m++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> n = j; n &lt; j + <span class="number">16</span> &amp;&amp; n &lt; M;n++) &#123;</span><br><span class="line">                    B[n][m] = A[m][n];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="Pasted_image_20230121122502.png"></p>
<p>miss次数为1993，擦线飘过</p>
<p>最后将代码放进transpose_submit中，在运行./driver.py，即可得到cachelab的分数</p>
<p><img src="Pasted_image_20230121124418.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>cache Lab让人有了一点leecode刷题的感觉了🤣，还是一如既往地借鉴各路大神的回答。还是比较建议大家在做lab之前，能够把课后习题给做一遍的（如果有大佬听过课就觉得理解透彻了，可以忽略）。通过cache lab，会对缓存的机制比较了解了，也基本理解局部性原理的意义，以前背八股的时候，局部性原理可能就是有个印象，与代码优化也不会产生任何联系。</p>
<p>Part A可以说是对C语言的考验，虽然提到了LRU，但是仅仅是最暴力的解法，如果用链表来写，那又是另一回事儿了。</p>
<p>Part B则是对矩阵的理解，转置竟然还能玩出这么多花样，分块是此前从未想到过的，而且最好的解题方法，还是需要自己去分析和画图，才能真正理解解法的意图。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xvic/p/16037046.html">CSAPP-Lab05 Cache Lab 深入解析 - Deconx - 博客园 (cnblogs.com)</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liqiuhao/p/8026100.html">CS:APP3e 深入理解计算机系统_3e CacheLab实验 - QiuhaoLi - 博客园 (cnblogs.com)</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">wenwenka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/">http://example.com/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">温温卡的blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CsApp/">CsApp</a></div><div class="post_share"><div class="social-share" data-image="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/"><img class="next-cover" src="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CsApp —— Attack Lab</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/" title="CsApp —— Attack Lab"><img class="cover" src="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-18</div><div class="title">CsApp —— Attack Lab</div></div></a></div><div><a href="/2023/01/09/CsApp-%E2%80%94%E2%80%94-Data-Lab/" title="CsApp —— Data Lab"><img class="cover" src="/2023/01/09/CsApp-%E2%80%94%E2%80%94-Data-Lab/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-09</div><div class="title">CsApp —— Data Lab</div></div></a></div><div><a href="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/" title="CsApp —— Bomb Lab"><img class="cover" src="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-10</div><div class="title">CsApp —— Bomb Lab</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wenwenka</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wenwenka" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/wu290063155@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-A"><span class="toc-number"></span> <span class="toc-text">Part A</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B8%A6%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">自带函数介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">核心代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">1.定义数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96Cache"><span class="toc-number">2.2.</span> <span class="toc-text">2.初始化Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LRU%E6%97%B6%E9%97%B4%E6%88%B3%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">3. LRU时间戳实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BC%93%E5%AD%98%E6%90%9C%E7%B4%A2%E5%8F%8A%E6%9B%B4%E6%96%B0"><span class="toc-number">2.4.</span> <span class="toc-text">4. 缓存搜索及更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90"><span class="toc-number">2.5.</span> <span class="toc-text">5. 指令解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-B"><span class="toc-number"></span> <span class="toc-text">Part B</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%C3%97-32"><span class="toc-number">2.</span> <span class="toc-text">32 × 32</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%C3%97-64"><span class="toc-number">3.</span> <span class="toc-text">64 × 64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%C3%97-67"><span class="toc-number">4.</span> <span class="toc-text">61 × 67</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5%EF%BC%9A"><span class="toc-number">0.1.</span> <span class="toc-text">参考链接：</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/" title="CsApp —— Cache Lab"><img src="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CsApp —— Cache Lab"/></a><div class="content"><a class="title" href="/2023/01/21/CsApp-%E2%80%94%E2%80%94-CacheLab/" title="CsApp —— Cache Lab">CsApp —— Cache Lab</a><time datetime="2023-01-21T14:42:00.000Z" title="发表于 2023-01-21 22:42:00">2023-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/" title="CsApp —— Attack Lab"><img src="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CsApp —— Attack Lab"/></a><div class="content"><a class="title" href="/2023/01/18/CsApp-%E2%80%94%E2%80%94-Attacklab/" title="CsApp —— Attack Lab">CsApp —— Attack Lab</a><time datetime="2023-01-18T14:07:00.000Z" title="发表于 2023-01-18 22:07:00">2023-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/" title="CsApp —— Bomb Lab"><img src="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CsApp —— Bomb Lab"/></a><div class="content"><a class="title" href="/2023/01/10/CsApp-%E2%80%94%E2%80%94-bomblab/" title="CsApp —— Bomb Lab">CsApp —— Bomb Lab</a><time datetime="2023-01-10T15:07:12.000Z" title="发表于 2023-01-10 23:07:12">2023-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/09/CsApp-%E2%80%94%E2%80%94-Data-Lab/" title="CsApp —— Data Lab"><img src="/2023/01/09/CsApp-%E2%80%94%E2%80%94-Data-Lab/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CsApp —— Data Lab"/></a><div class="content"><a class="title" href="/2023/01/09/CsApp-%E2%80%94%E2%80%94-Data-Lab/" title="CsApp —— Data Lab">CsApp —— Data Lab</a><time datetime="2023-01-09T15:07:12.000Z" title="发表于 2023-01-09 23:07:12">2023-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/08/%E5%BA%8F%E7%AB%A0/" title="序章"><img src="/img/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="序章"/></a><div class="content"><a class="title" href="/2023/01/08/%E5%BA%8F%E7%AB%A0/" title="序章">序章</a><time datetime="2023-01-08T13:50:31.000Z" title="发表于 2023-01-08 21:50:31">2023-01-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wenwenka</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>